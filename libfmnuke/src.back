#__mcat: anahdr.F     **DO NOT DELETE
      SUBROUTINE ANAHDR(MAXHDR,NRHDR,HDR100,ACTHDR,NRLEN,
     &        CODHDR,PPDAT,MAXGRP,NRGRP,HDRGRP,
     &        IRC)
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 NROPT
      PARAMETER(NROPT=5)
C
      INTEGER*4 MAXHDR, NRHDR
      CHARACTER*100 HDR100(MAXHDR)
      LOGICAL*4 ACTHDR(MAXHDR)
      INTEGER*4 NRLEN(MAXHDR), CODHDR(MAXHDR)
      LOGICAL*4 PPDAT(NROPT,MAXHDR)
      INTEGER*4 MAXGRP, HDRGRP(2,MAXGRP,MAXHDR),NRGRP
      INTEGER*4 IRC
C
      LOGICAL*4 FOUND,BDONE,BBDONE
      INTEGER*4 CURP,CURK,CUR,
     &     LENH,LENGTH,II,JJ,KK,POS(2),LEV,MINGRP
      EXTERNAL LENGTH
      CHARACTER*100 BUFF2
      CHARACTER*1 DEL(2),OPT,OPTL(NROPT),OPTG(5)
      DATA OPTL /'V','F','M','L','R'/
      DATA OPTG /'?','&','%','$','@'/
      CHARACTER*8 MYNAME
      DATA MYNAME/'ANAHDR'/
C
C
C     FIND LENGTH OF HEADER, AND LOCATION OF []...
C
      NRGRP=0
      MINGRP=0
      LENH=1
      II=1
      DO WHILE(II.LE.MAXHDR)
         CALL CHOP(HDR100(II),100)
         LENH=LENGTH(HDR100(II),100,LENH)
         IF (LENH.EQ.0) THEN
C     THE HEADER IS BLANK
            ACTHDR(II)=.FALSE.
         ELSE
            ACTHDR(II)=.TRUE.
            NRHDR=II
            LEV=0
            DEL(1)='['
            DEL(2)=']'
            POS(1)=1
            POS(2)=100
            CALL ITEM(HDR100(II),100,DEL,LEV,POS,IRC)
            IF (IRC.NE.0 .OR. LEV .EQ. -1) THEN
               WRITE(*,*) MYNAME,
     &              'Error: missing [] in header, ',II,'.'
               IF(IRC.EQ.0) IRC=100
               RETURN
            ENDIF
            NRLEN(II)=POS(1)-1
            IF (NRLEN(II).NE.0) THEN
               IF (HDR100(II)(NRLEN(II):NRLEN(II)).EQ.' ')
     &              NRLEN(II)=NRLEN(II)-1
            ELSE
               WRITE(*,*) MYNAME,'Error: header too short, ',II,'.'
               IF(IRC.EQ.0) IRC=101
            ENDIF
C
C     GET LENGTH OF DATA-BODY
C
            IF (HDR100(II)(POS(1)+1:POS(2)-1).EQ.'*') THEN
               CODHDR(II)=-1
            ELSE
               READ(HDR100(II)(POS(1)+1:POS(2)-1),*,IOSTAT=IRC) 
     &              CODHDR(II)
               IF (IRC.NE.0) THEN
                  WRITE(*,*) MYNAME,'Unable to read length of'//
     &                 ' data body for header ',II,'.'
                  RETURN
               END IF
            END IF
C     
C     CHECK FOR PRE-PROCESSING
C     
            DO KK=1,NROPT
               PPDAT(KK,II)=.FALSE.
            ENDDO
C
            DO KK=1,MAXGRP
               HDRGRP(1,KK,II)=0
               HDRGRP(2,KK,II)=0
            END DO
C
            BUFF2=HDR100(II)(POS(2)+1:LENH)
            CURP=-1
            CURK=-1
            CUR=0
            LENH=LENH-POS(2)
C
C     CHECK FOR PRE-PROCESSOR FLAGS
C
            JJ=1
            BDONE=(JJ.GT.LENH)
            DO WHILE (.NOT.BDONE)
               OPT=BUFF2(JJ:JJ)
               FOUND=.FALSE.
C
C     CHECK FOR "VFMLR" FLAGS
C
               KK=1
               BBDONE=(KK.GT.NROPT)
               DO WHILE (.NOT.FOUND.AND..NOT.BBDONE)
                  IF (OPT.EQ.OPTL(KK)) THEN
                     PPDAT(KK,II)=.TRUE.
                     FOUND=.TRUE.
                     BBDONE=.TRUE.
                  ELSE
                     KK=KK+1
                     BBDONE= (KK.GT.NROPT) 
                  ENDIF
               END DO
C
C     CHECK FOR GROUP FLAGS
C     
               KK=1
               BBDONE=(KK.GT.5)
               DO WHILE(.NOT.FOUND.AND..NOT.BBDONE)
                  IF (OPT.EQ.OPTG(KK)) THEN
                     IF (CURP.NE.-1) THEN
                        CUR=CUR+1
                        NRGRP=MAX(NRGRP,CUR)
                        IF (CUR.GT.MAXGRP) THEN
                           WRITE(*,*) MYNAME,
     &                          'Too many HDR groups.',CUR
                           IRC=993
                           RETURN
                        END IF
                        IF (CURP+1.GT.JJ-1) THEN
                           HDRGRP(1,CUR,II)=1
                           HDRGRP(2,CUR,II)=CURK
                        ELSE
                           READ(BUFF2(CURP+1:JJ-1),*) HDRGRP(1,CUR,II)
                           HDRGRP(1,CUR,II)=HDRGRP(1,CUR,II)+2
                           HDRGRP(2,CUR,II)=CURK
                        END IF
                        MINGRP=MIN(MINGRP,HDRGRP(1,CUR,II))
                     END IF
                     CURP=JJ
                     CURK=KK
                     FOUND=.TRUE.
                     BBDONE=.TRUE.
                  ELSE
                     KK=KK+1
                     BBDONE=(KK.GT.5)
                  END IF
               END DO
C     
               IF (.NOT.FOUND) THEN
                  IF (OPT.EQ.' '.OR.(CURP.NE.-1.AND.(
     &                 OPT.EQ.'0'.OR.OPT.EQ.'1'.OR.
     &                 OPT.EQ.'2'.OR.OPT.EQ.'3'.OR.
     &                 OPT.EQ.'4'.OR.OPT.EQ.'5'.OR.
     &                 OPT.EQ.'6'.OR.OPT.EQ.'7'.OR.
     &                 OPT.EQ.'8'.OR.OPT.EQ.'9'))) THEN
                     FOUND=.TRUE.
                  END IF
               END IF
C     
               IF (.NOT.FOUND) THEN
                  WRITE(*,*) MYNAME,
     &                 'Error: unknown header option, ',
     &                 OPT,'.'
                  IRC=999
                  RETURN
               ENDIF
C
               JJ=JJ+1
               BDONE=(JJ.GT.LENH)
C
            ENDDO
C
C     PROCESS LAST GROUP FLAG
C
            IF (CURP.NE.-1) THEN
               CUR=CUR+1
               NRGRP=MAX(NRGRP,CUR)
               IF (CUR.GT.MAXGRP) THEN
                  WRITE(*,*) MYNAME,
     &                 'Too many HDR groups.',CUR
                  IRC=993
                  RETURN
               END IF
               IF (CURP+1.GT.JJ-1) THEN
                  HDRGRP(1,CUR,II)=1
                  HDRGRP(2,CUR,II)=CURK
               ELSE
                  READ(BUFF2(CURP+1:JJ-1),*) HDRGRP(1,CUR,II)
                  HDRGRP(1,CUR,II)=HDRGRP(1,CUR,II)+2
                  HDRGRP(2,CUR,II)=CURK
               END IF
               MINGRP=MIN(MINGRP,HDRGRP(1,CUR,II))
            END IF
C
C     GET INFO CONCERNING THE NUMBER OF LINES IN THE DATA BODY
C     
C     
         ENDIF
         II=II+1
      ENDDO
C
C     MAKE SURE BLANK-GROUP-HEADERS ARE MARKED AS SINGLE 'OR'-GROUPS (1 OR ZERO)
C
      DO II=1,NRHDR
         IF (ACTHDR(II)) THEN
C     
            IF (HDRGRP(1,1,II).EQ.0) THEN
               MINGRP=MINGRP-1
               HDRGRP(1,1,II)=MINGRP
               HDRGRP(2,1,II)=1
            END IF
C     
         END IF
      END DO
C     
      END

#__mcat: analfl.F     **DO NOT DELETE
      subroutine ANALFL(MAXHDR,NRHDR,HDR100,
     &     ACTHDR,LFLDAT,NRLEN,
     &     MAXGRP,NRGRP,HDRGRP,
     &     IRC)
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 NROPT
      PARAMETER(NROPT=5)
C
      INTEGER*4 MAXHDR, NRHDR
      CHARACTER*100 HDR100(MAXHDR),BHDR100(MAXHDR),BBHDR100
      LOGICAL*4 ACTHDR(MAXHDR),LFLDAT(MAXHDR),BLFLDAT(MAXHDR),BBLFLDAT
      INTEGER*4 NRLEN(MAXHDR),BNRLEN(MAXHDR),BBNRLEN
      INTEGER*4 MAXGRP,NRGRP,
     &     HDRGRP(2,MAXGRP,MAXHDR),BHDRGRP(2,MAXGRP,MAXHDR),
     &     BBHDRGRP(2,MAXGRP)
      INTEGER*4 IRC
C
      INTEGER*4 II, JJ, KK, LL, MM, CNT,ST,EN,ENHDR
      INTEGER*4 INRHDR,IND(MAXHDR+1)
      LOGICAL*4 LAND,BDONE,LSET,FOUND,OK,QLFL
      EXTERNAL QLFL
      CHARACTER*8 MYNAME
      DATA MYNAME /'ANALFL'/
C
C     SORT HDR ARRAY ACCORDING GROUP
C
      OK=.TRUE.
      CNT=0
      DO II=1,NRHDR
         IF (ACTHDR(II)) THEN
            CNT=CNT+1
            BHDR100(CNT)=HDR100(II)
            BLFLDAT(CNT)=LFLDAT(II)
            BNRLEN(CNT)=NRLEN(II)
            DO JJ=1,MAXGRP
               BHDRGRP(1,JJ,CNT)=HDRGRP(1,JJ,II)
               BHDRGRP(2,JJ,CNT)=HDRGRP(2,JJ,II)
            END DO
         END IF
      END DO
C
      DO II=2,CNT
         JJ=II
         BDONE = QLFL(MAXGRP,NRGRP,BHDRGRP(1,1,JJ-1),BHDRGRP(1,1,JJ))
         DO WHILE (.NOT.BDONE)
C     FLIP
            BBHDR100=BHDR100(JJ)
            BBLFLDAT=BLFLDAT(JJ)
            BBNRLEN=BNRLEN(JJ)
            DO KK=1,MAXGRP
               BBHDRGRP(1,KK)=BHDRGRP(1,KK,JJ)
               BBHDRGRP(2,KK)=BHDRGRP(2,KK,JJ)
            END DO
C
            BHDR100(JJ)=BHDR100(JJ-1)
            BLFLDAT(JJ)=BLFLDAT(JJ-1)
            BNRLEN(JJ)=BNRLEN(JJ-1)
            DO KK=1,MAXGRP
               BHDRGRP(1,KK,JJ)=BHDRGRP(1,KK,JJ-1)
               BHDRGRP(2,KK,JJ)=BHDRGRP(2,KK,JJ-1)
            END DO
C
            BHDR100(JJ-1)=BBHDR100
            BLFLDAT(JJ-1)=BBLFLDAT
            BNRLEN(JJ-1)=BBNRLEN
            DO KK=1,MAXGRP
               BHDRGRP(1,KK,JJ-1)=BBHDRGRP(1,KK)
               BHDRGRP(2,KK,JJ-1)=BBHDRGRP(2,KK)
            END DO
C
            JJ=JJ-1
            BDONE=(JJ.LE.1)
            IF (.NOT. BDONE) 
     &           BDONE = QLFL(MAXGRP,NRGRP,
     &           BHDRGRP(1,1,JJ-1),BHDRGRP(1,1,JJ))
C
         END DO
      END DO
C
C     START FROM BACK, ELIMINATE GROUPS
C
      INRHDR=CNT
      DO II=1,INRHDR
         IND(II)=II
      END DO
      IND(INRHDR+1)=INRHDR+1
C
      OK=.TRUE.
      DO JJ=NRGRP,1,-1
C     
         ST=1
         EN=ST
         DO WHILE (ST.LE.CNT)
C
            IF (BHDRGRP(1,JJ,IND(ST)).NE.0) THEN
C
C     FIND END OF GROUP
C
               FOUND=QLFL(MAXGRP,JJ,
     &              BHDRGRP(1,1,IND(MIN(EN+1,CNT))),
     &              BHDRGRP(1,1,IND(ST)))
               BDONE=(.NOT.FOUND)
               DO WHILE (.NOT.BDONE)
                  EN =MIN(EN+1,CNT)
                  FOUND=QLFL(MAXGRP,JJ,
     &                 BHDRGRP(1,1,IND(MIN(EN+1,CNT))),
     &                 BHDRGRP(1,1,IND(ST)))
                  IF (.NOT.FOUND) THEN
                     BDONE=.TRUE.
                  END IF
                  IF (.NOT.BDONE) BDONE=(EN.GE.CNT)
               END DO
C     
C     DETERMINE IF GROUP QUALIFIES ACCORDING TO SPECIFICATIONS
C
               LL=0
               DO KK=ST,EN
                  IF (BLFLDAT(IND(KK)))  LL=LL+1
               END DO
               IF (BHDRGRP(2,JJ,IND(ST)).EQ.2) THEN ! "&" group
                  IF (JJ.EQ.1 .OR.
     &                 (LL.NE.0 .AND. LL.NE.(EN-ST+1))) THEN 
C     only all or 0 headers allowed
                     DO KK=ST,EN
                        IF (.NOT.BLFLDAT(IND(KK))) THEN ! too few headers
                           IF (JJ.LT.NRGRP) THEN ! check if '?' is used
                              IF (.NOT.BHDRGRP(2,JJ+1,IND(KK))
     &                             .EQ.1) THEN
                                 WRITE(*,*) MYNAME,
     &                                'Missing the header:'//
     &                                BHDR100(IND(KK))(1:BNRLEN(
     &                                IND(KK)))
                                 OK=.FALSE.
                              END IF
                           ELSE
                              WRITE(*,*) MYNAME,
     &                             'Missing the header:'//
     &                             BHDR100(IND(KK))(1:BNRLEN(IND(KK)))
                              OK=.FALSE.
                           END IF
                        END IF
                     END DO
                  END IF
               ELSE IF (BHDRGRP(2,JJ,IND(ST)).EQ.3) THEN ! "%" group
                  IF (LL.GT.1) THEN 
C     only 1 or 0 headers allowed
                     LL=0
                     DO KK=ST,EN
                        IF (BLFLDAT(IND(KK)))  LL=LL+1
                        IF (LL.GT.1) THEN
                           ENHDR=IND(KK+1)-1
                           DO MM=IND(KK),ENHDR
                              IF (BLFLDAT(MM)) THEN ! too many headers
                                 WRITE(*,*) MYNAME,
     &                                'Redundant header:'//
     &                                BHDR100(MM)(1:BNRLEN(MM))
                                 OK=.FALSE.
                              END IF
                           END DO
                        END IF
                     END DO
                  END IF
               ELSE IF (BHDRGRP(2,JJ,IND(ST)).EQ.4) THEN ! "$" group
C     any number of headers allowed
                  IF (JJ.EQ.1.AND.LL.EQ.0) THEN
                     DO KK=ST,EN
                        IF (.NOT.BLFLDAT(IND(KK))) THEN ! too few headers
                           IF (JJ.LT.NRGRP) THEN ! check if '?' is used
                              IF (.NOT.BHDRGRP(2,JJ+1,IND(KK))
     &                             .EQ.1) THEN
                                 WRITE(*,*) MYNAME,
     &                                'Missing at least one header:'//
     &                                BHDR100(IND(KK))(1:
     &                                BNRLEN(IND(KK)))
                                 OK=.FALSE.
                              END IF
                           ELSE
                              WRITE(*,*) MYNAME,
     &                             'Missing at least one header:'//
     &                             BHDR100(IND(KK))(1:BNRLEN(IND(KK)))
                              OK=.FALSE.
                           END IF
                        END IF
                     END DO
                  END IF
               END IF
C     
               IF (.NOT.OK) THEN
                  IRC=391
                  RETURN
               END IF
C     
C     REMOVE SURPLUS HEADERS FROM ANALYSIS...
C
               LSET=(LL.NE.0)   ! SHOULD WE DEGENERATE TO 'SET'-FLAG?
C     
               FOUND =.FALSE.
               KK=ST
               DO WHILE (KK.LE.EN)
                  IF (FOUND .OR.  .NOT.( ! and
     &                 (LSET.AND.BLFLDAT(IND(KK))).OR.
     &                 (.NOT.LSET.AND..NOT.BLFLDAT(IND(KK))))
     &                 ) THEN
                  ELSE
                     IND(ST)=IND(KK)
                     FOUND=.TRUE.
                  END IF
C     
C     REMOVE FROM ANALYSIS
C     
                  IF (KK.NE.ST) THEN
                     DO LL=KK,CNT-1
                        IND(LL)=IND(LL+1)
                     END DO
                     CNT=CNT-1
                     EN=EN-1
                  ELSE
                     KK=KK+1
                  END IF
C     
               END DO
            END IF
C
            ST=EN+1
            EN=ST
C     
         END DO
C     
      END DO
C
      return
      end
#__mcat: argument.F     **DO NOT DELETE
      SUBROUTINE ARGUMENT(STRING,N,CPOS,BUFF,QQ,RR)
C
C     FINDS UP TO TWO ARGUMENTS OF A FUNCTION
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N
      CHARACTER*1 STRING(N)
C
      CHARACTER*100 BUFF,BUFF1,BUFF2,BUFF3,NUKEHEAD
C
      INTEGER*4 LENB1,LENB2,LENB3,LENGTH
      EXTERNAL LENGTH,NUKEHEAD
      LOGICAL*4 QQ(2),QQ1,QQ2,ISINT,ISREAL
      EXTERNAL ISINT,ISREAL
      INTEGER*4 CPOS,POS2(2),CODE,
     &     RI1,RI2
      REAL*8 RR(2),RR1,RR2
C
      CHARACTER*8 MYNAME
      DATA MYNAME /'ARGUMENT'/
      INTEGER*4 IRC
C
      LOGICAL*4 ACTIVE,BDEB
      DATA ACTIVE /.FALSE./
C
      IF (.NOT.ACTIVE) CALL DEBUG(MYNAME,BDEB,ACTIVE)
C
      IF (BDEB) WRITE(*,*) MYNAME,'Debug: Routine starts.',IRC
C
C     FIND NEXT OBJECT
C
      CODE=+1
      CALL OBJECT(STRING,N,CPOS,POS2,CODE)
      CALL RESET(BUFF1,100)
      CALL CEQUAL(BUFF,100,STRING,POS2(1),POS2(2))
      CALL CHOP(BUFF,100)
      BUFF1=BUFF
      LENB1=LENGTH(BUFF1,100,LENB1)
C
C     INITIALISE
C
      QQ1=.FALSE.
      QQ2=.FALSE.
      RR1=0.0D0
      RR2=0.0D0
C
C     ANALYSE OBJECT
C
      IF (QQ(1)) THEN
C     FIND FIRST NUMERICAL ARGUMENT
         BUFF2=NUKEHEAD(BUFF1,100)
         BUFF3=BUFF1
         LENB2=LENGTH(BUFF2,100,LENB2)
         LENB3=LENGTH(BUFF3,100,LENB3)
         QQ1=ISREAL(BUFF2,RR1)
         IF (.NOT.QQ1) THEN
            QQ1=ISINT(BUFF2,RI1)
            IF (QQ1) RR1=DFLOAT(RI1)
         ENDIF
C
         IF (BDEB) WRITE(*,*) MYNAME,'Debug:',QQ1,BUFF2,RR1
C
         IF (QQ1.AND.QQ(2)) THEN
C     FIND SECOND ARGUMENT
            LENB3=LENGTH(BUFF3,100,LENB3)
            QQ2=ISREAL(BUFF3,RR2)
            IF (.NOT.QQ2) THEN
               QQ2=ISINT(BUFF3,RI2)
               IF (QQ2) RR2=DFLOAT(RI2)
            ENDIF
C
            IF (BDEB) WRITE(*,*) MYNAME,'Debug:',QQ2,BUFF3,RR2
C
         ELSEIF (QQ1) THEN
            QQ1=(LENB3.EQ.0)
         ENDIF
      ENDIF
C
C     ASSIGN NEW VALUES
C
      QQ(1)=QQ1
      QQ(2)=QQ2
      RR(1)=RR1
      RR(2)=RR2
C
      IF (BDEB) WRITE(*,*) MYNAME,'Debug: Routine ends.',IRC
C
      RETURN
      END
#__mcat: atom.F     **DO NOT DELETE
      LOGICAL*4 FUNCTION ATOM(STRING,N)
C     ***********************************************************************
C     +                                                                     *
C     CHECK IF STRING CONSISTS OF A SINGLE OBJECT                           *
C     ....(THAT DOES NOT NEED BRACKETS)                                     *
C     +                                                                     *
C     +                                                                     *
CI    STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    N (I*4) = LENGTH OF STRING                                            *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N
      CHARACTER*1 STRING(N)
C
      INTEGER*4 LENS,LENGTH,POS(2),CODE,START
      EXTERNAL LENGTH
      LOGICAL*4 BUFF
C
      CALL CHOP(STRING,N)
      LENS=LENGTH(STRING,N,1)
C
      START=1
      CODE=1
      CALL OBJECT(STRING,N,START,POS,CODE)
C
      BUFF=(POS(1).EQ.1 .AND. POS(2).EQ.LENS)
C
      ATOM=BUFF
C
      RETURN
      END
#__mcat: blobb.F     **DO NOT DELETE
      SUBROUTINE BLOBB
C
      IMPLICIT NONE
      SAVE
C
C
      LOGICAL*4 FIRST,ONCE
      DATA FIRST /.TRUE./
      DATA ONCE /.FALSE./
C
      CHARACTER*72 STR(29)
      INTEGER*4 JJ
C
      INTEGER*4 UNITI,FTUNIT,IRC
      EXTERNAL FTUNIT
      CHARACTER*8 MYNAME
      DATA MYNAME /'BLOBB'/
C
      IF (FIRST) THEN
         STR(1)='                                   '//
     &        '                          ..         '
         STR(2)='                                  ,,'//
     &        ',                         MM .M     '
         STR(3)='                              ,!MMMM'//
     &        'MMM!,                     MM MM  ,. '
         STR(4)='      ., .M                .MMMMMMMM'//
     &        'MMMMMMMM.,          `MM.  MM MM .M` '
         STR(5)='    . M: M;  M          .MMMMMMMMMMM'//
     &        'MMMMMMMMMMM,          `MM,:M M`!M`  '
         STR(6)='   ;M MM M: .M        .MMMMMMMMMMMMM'//
     &        'MMMMMMMMMMMMM,         `MM`...`M    '
         STR(7)='    M;MM;M :MM      .MMMMMMMMMMMMMMM'//
     &        'MMMMMMMMMMMMMMM.       .MMMMMMMM    '
         STR(8)='    `M;M`M MM      MMMMMM  MMMMMMMMM'//
     &        'MMMMMMMM  MMMMMM.    ,,M.M.`MMM`    '
         STR(9)='     MM`MMMM      MMMMMM @@ MMMMMMMM'//
     &        'MMMMMMM @@ MMMMMMM.`M``MMMM;MM`     '
         STR(10)='    MM., ,MM     MMMMMMMM  MMMMMMMMM'//
     &        'MMMMMMMM  MMMMMMMMM      `.MMM      '
         STR(11)='    `MM;MMMMMMMM.MMMMMMMMMMMMMMMMMMM'//
     &        'MMMMMMMMMMMMMMMMMMM.      `MMM      '
         STR(12)='     ``.`MMM`  .MMMMMMMMMMMMMMMMMMMM'//
     &        'MMMMMMMMMMMMMMMMMMMM       MMMM     '
         STR(13)='      MMC      MMMMMMMMMMMMMMMMMMMMM'//
     &        'MMMMMMMMMMMMMMMMMMMM.      `MMMM    '
         STR(14)='     .MM      :MMMMMMMMMMMMMMMMMMMMM'//
     &        'MMMMMMMMMMMMMMMM``MMM       MMMMM   '
         STR(15)='     MMM      :M  `MMMMMMMMMMMMM.MMM'//
     &        'MM.MMMMMMMMMM`.MM  MM:M.    `MMMMM  '
         STR(16)='    .MMM   ...:M: :M.`MMMMMMMMMMMMMM'//
     &        'MMMMMMMMMMM`.M``   MM:MMMMMMMMMMMM` '
         STR(17)='   AMMM..MMMMM:M.    :M.`MMMMMMMMMMM'//
     &        'MMMMMMMMM`.MM`     MM````````````   '
         STR(18)='   MMMMMMMMMMM:MM     `M`.M`MMMMMMMM'//
     &        'MMMMMM`.MC`M`     .MM               '
         STR(19)='    ``````````:MM.       `MM!M.`M-M-'//
     &        'M-M`M.`MM`        MMM               '
         STR(20)='               MMM.            `MMMM'//
     &        '!MMMM`            .MM               '
         STR(21)='                MMM.             ```'//
     &        '   ``            .MM`               '
         STR(22)='                 MMM.               '//
     &        '                MMM`                '
         STR(23)='                  MMMM            ,.'//
     &        'J.JJJJ.       .MMM`                 '
         STR(24)='                   MMMM.       `JJJJ'//
     &        'JJJ`JJJM   CMMMMM                   '
         STR(25)='                     MMMMM.    `JJJJ'//
     &        'JJJJ`JJJ .MMMMM`                    '
         STR(26)='                       MMMMMMMM.`  `'//
     &        'JJJJJ`JJMMMMM`                      '
         STR(27)='                         `MMMMMMMMM`'//
     &        'JJJJJ JJJJJ`                        '
         STR(28)='                            ``MMMMMM'//
     &        'JJJJJJJJJJ`                         '
         STR(29)='                                    '//
     &        '`JJJJJJJJ`                          '
      ENDIF
C
      IF (ONCE) THEN
C
C     OPEN FILE
C
         IRC=0
         UNITI=FTUNIT(IRC)
         OPEN(UNIT=UNITI,FILE='.blobb',STATUS='OLD',
     +        ACCESS='SEQUENTIAL', FORM='FORMATTED',IOSTAT=IRC)
C
         IF (IRC.NE.0) THEN
C
            OPEN(UNIT=UNITI,FILE='.blobb',STATUS='UNKNOWN',
     +           ACCESS='SEQUENTIAL', FORM='FORMATTED',IOSTAT=IRC)
C     
C     WRITE "BLOBB" TO FILE AND SCREEN
C     
            IF (IRC.NE.0) THEN
               WRITE(*,*)
               WRITE(UNITI,*)
               DO JJ=1,29
                  WRITE(*,*) STR(JJ)
                  WRITE(UNITI,*) STR(JJ)
               ENDDO
               WRITE(*,*)
               WRITE(UNITI,*)
               CLOSE(UNITI)
            END IF
         ELSE
            CLOSE(UNITI)
         END IF
C
      ELSE
C
C     WRITE "BLOBB" TO SCREEN
C
         WRITE(*,*)
         DO JJ=1,29
            WRITE(*,*) STR(JJ)
         ENDDO
         WRITE(*,*)
      ENDIF
C
      RETURN
      END
#__mcat: cequal.F     **DO NOT DELETE
      SUBROUTINE CEQUAL(STRING1,N,STRING2,POS1,POS2)
C     ***********************************************************************
C     +                                                                     *
C     SETS STRING1 EQUAL TO STRING2 (FROM POS1 TO POS2)                     *
C     +                                                                     *
CO    STRING1 (C*N1) = STRING TO BE OVERWRITTEN                             *
CI    N1 (I*4) = LENGTH OF STRING                                           *
CI    STRING2 (C*N2) = STRING FROM WHICH TO COPY DATA, WHERE N2y.GT.POS2     *
CI    POS1 (I*4) = START POSITION IN STRING2 FROM WHICH TO START COPYING    *
CI    POS2 (I*4) = END POSITION IN STRING2 FROM WHICH TO END COPYING        *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N,POS1,POS2
      CHARACTER*(*) STRING1, STRING2
      CHARACTER*1 C1
C
      INTEGER*4 II,MAXX
C
      LOGICAL*4 FIRST
      DATA FIRST /.TRUE./
C
      IF (FIRST) THEN
         C1=CHAR(0)
         FIRST=.FALSE.
      ENDIF
C
      MAXX=MIN(N,POS2-POS1+1)
C
      DO II=1,MAXX
         STRING1(II:II)=STRING2(POS1+II-1:POS1+II-1)
      ENDDO
      MAXX=MAXX+1
      IF (MAXX.LT.N) THEN
         DO II=MAXX,N
            STRING1(II:II)=C1
         ENDDO
      ENDIF
C
      RETURN
      END
#__mcat: chop.F     **DO NOT DELETE
      SUBROUTINE CHOP(STRING,N)
C     ***********************************************************************
C     +                                                                     *
C     REMOVES SURPLUS BLANKS FROM A STRING                                  *
C     +                                                                     *
CIO   STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    N (I*4) = LENGTH OF STRING                                            *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N
      CHARACTER*(*) STRING
      CHARACTER*1 C1
      INTEGER*4 II,JJ
      LOGICAL*4 LASTBL
C
      LOGICAL*4 FIRST
      DATA FIRST /.TRUE./
C
      IF (FIRST) THEN
         C1=CHAR(0)
         FIRST=.FALSE.
      ENDIF
C
      LASTBL=.TRUE.
      JJ=0
      II=0
      DO WHILE(II.LT.N)
         II=II+1
         IF (LASTBL .AND. STRING(II:II).EQ.C1) THEN
            II=N
         ELSE
            IF (STRING(II:II).NE.' ' .AND.
     &           STRING(II:II).NE.C1) THEN
C     ADDING CHARACTER TO BUFF
               JJ=JJ+1
               STRING(JJ:JJ)=STRING(II:II)
               LASTBL=.FALSE.
            ELSEIF (.NOT.LASTBL) THEN
C     ADDING (*ONE*) BLANK TO BUFF
               JJ=JJ+1
               STRING(JJ:JJ)=' '
               LASTBL=.TRUE.
            ENDIF
         ENDIF
      ENDDO
C
      IF (.NOT.LASTBL.OR.JJ.EQ.0) JJ=JJ+1
C
      DO II=JJ,N
         STRING(II:II)=C1
      ENDDO
      RETURN
      END
#__mcat: cleanup.F     **DO NOT DELETE
      SUBROUTINE CLEANUP(STRING,N)
C     ***********************************************************************
C     +                                                                     *
C     REMOVES {}, AND REPLACES [] WITH () IN STRING                         *
C     +                                                                     *
CIO   STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    N (I*4) = LENGTH OF STRING                                            *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N
      CHARACTER*1 STRING(N),BUFF
C
      INTEGER*4 II,LENGTH,LENS,DELL,IIZERO
      LOGICAL*4 DIGIT,ACTIVE
      EXTERNAL LENGTH,DIGIT
C
      LENS=LENGTH(STRING,N,1)
      DELL=1
      II=1
      DO WHILE(II.LE.LENS)
C     REPLACE [] WITH ()
         IF (STRING(II).EQ.'[') THEN
            BUFF='('
            CALL SUBSTR(STRING,N,BUFF,1,II,DELL)
         ELSEIF (STRING(II).EQ.']') THEN
            BUFF=')'
            CALL SUBSTR(STRING,N,BUFF,1,II,DELL)
         ENDIF
C     REMOVE 'PROTECTIVE BRACKETS' {}, OR GOTO NEXT CHARACTER
         IF (STRING(II).EQ.'{'.OR.STRING(II).EQ.'}') THEN
            CALL SUBSTR(STRING,N,BUFF,0,II,DELL)
            LENS=LENS-1
         ELSE
            II=II+1
         ENDIF
      ENDDO
C
      LENS=LENGTH(STRING,N,LENS)
      CALL CHOP(STRING,LENS)
C
      RETURN
      END
#__mcat: coot20.F     **DO NOT DELETE
      SUBROUTINE COOT20
C
C  PREPARATION OF IMPORTANT CONSTANTS FOR EARTH SATELLITE DYNAMICS FOR
C  THE EPOCH J2000.0 THAT ARE RECOMMENDED BY THE INTERNATIONAL EARTH
C  ROTATION SERVICE IN THE IERS TECHNICAL NOTE 3: IERS STANDARDS 1989.
C  TIME IS EXPRESSED IN MODIFIED JULIAN DAYS MJD2000, COUNTED FROM
C  2000 JANUARY 1 AT 00:00:00 HOURS.  MJD2000 = MJD1950 - 18262.
C
      IMPLICIT REAL*8(A-H,O-Z)
      SAVE
      CHARACTER*40 SCCS_INFO
      DATA SCCS_INFO
     & /'@(#)coot20.f       1.2 3/1/94 ORBLIB\n'/
      COMMON /CBASIC/ PI,TWOPI,PIH,DEG,RAD
      COMMON /CGEOME/ RE,FLAT,FLATSQ,CLIGHT
      COMMON /CPOEMS/ XMU,WMU,WMUIN,XMUM,XMUS
      COMMON /CDYNAE/ STD20,OMT20,OMQ20,OMROT,STD20R,OMT20R,OMQ20R
      COMMON /CSOLAR/ SOLPR,ECL,CECL,SECL,XLSUNA,XLSUNB,ECLECC,ECLOM
      COMMON /CORIOL/ PRACCY,PRACCZ
C
C  PI = 3.141592653589793238...ETC
      PIH = DATAN2(1.D0,0.D0)
      PI = PIH + PIH
      TWOPI = PI + PI
C  FOR CONVERTING ANGLES FROM RADIANS TO DEGREES AND BACK
      DEG = 18.D1/PI
      RAD = PI/18.D1
C
C  RE = MEAN RADIUS OF EQUATOR, KM
C      RE = 6378.136 D0
      RE = 6378.155 D0
C  FLAT = FLATTENING COEFFICIENT
      FLAT = 1.D0/298.257 D0
      FLATSQ = FLAT*(2.D0-FLAT)
C  CLIGHT = SPEED OF LIGHT, KM/SEC. CONVENTIONAL ADOPTED VALUE.
      CLIGHT = 299792.458 D0
C
C  XMU = CENTRAL EARTH POTENTIAL, KM**3/SEC**2
      XMU = 398600.440 D0
      WMU = DSQRT(XMU)
      WMUIN=1.D0/WMU
C
C  XMUM = MOON POTENTIAL, KM**3/SEC**2
      XMUM = XMU*12.300034 D-3
C  XMUS = SUN POTENTIAL, KM**3/SEC**2
      XMUS = 132712440. D3
C
C  THE = GREENWICH SIDEREAL ANGLE IS PROVIDED BY:
C  STD20, OMT20, OMQ20 IN DEGREES AND STD20R, OMT20R, OMQ20R IN RADIANS:
C     W = STD20 + OMT20*DAY + OMQ20*DAY*DAY
C  WITH 'DAY' (ACTUALLY UT1) IN MJD2000.
C
C  CONSTANT TERM = AN = 6 HOURS + 41 MIN + 50.54841 SEC
C  CONVERSION OF RIGHT ASCENSION FROM SECONDS TO DEGREES = 1/240.
      AN = ((36.D1 + 41.D0)*6.D1 + 50.54841D0)/24.D1
C
C  LINEAR TERM = BN = 8640184.812866 SEC/JULIAN CENTURY
      BN = 8640184.812866 D0 /(36525.D0 * 24.D1)
C
C  QUADRATIC TERM = OMQ20 = 0.93104D-1 SEC/(JULIAN CENTURY)**2
      OMQ20 = 0.93104D-1 /(24.D1 * 36525.D0**2)
C
C  3RD DEGREE TERM = -6.2D-6 SEC/(JULIAN CENTURY)**3 IS OMITTED.
C
C  TRANSFORM BY 0.5 DAY FROM J2000.0 = 2000 JAN 1 AT 12 HOURS TO
C  'DAY' IN MJD2000 FROM 0 HOURS.
      STD20 = AN - (BN - OMQ20*0.5D0)*0.5D0
C  SAME TRANSFORM OF ROTATION RATE BY 0.5 DAY, ADD 360 DEG/DAY
      OMT20 = BN - OMQ20 + 36.D1
C  SAME IN RADIANS:
      STD20R = STD20*RAD
      OMT20R = OMT20*RAD
      OMQ20R = OMQ20*RAD
C  OMROT = MEAN VELOCITY OF ROTATION OF THE EARTH (RAD/SEC)
      OMROT = OMT20R/864. D2
C
C  ECL = OBLIQUITY OF ECLIPTIC AT EPOCH J2000.0;
C  ECL CHANGES BY -0.01300 DEG/CENTURY.
C  ECL = 23 DEG + 26 ' + 21.4119 "
      ECL = RAD*(23.D0 + (26.D0 + 21.4119D0/6.D1)/6.D1)
C  CECL, SECL = COSINE & SINE OF OBLIQUITY OF ECLIPTIC
      CECL = DCOS(ECL)
      SECL = DSIN(ECL)
C
C  SOLPR = RADIATION PRESSURE AT MEAN EARTH DISTANCE FROM THE SUN,
C   KG*KM/(M*SEC)**2
      SOLPR = 4.56 D-9
C
C  XLSUNA, XLSUNB, ECLECC, ECLOM GIVE WITH A PRECISION OF 0.02 DEG
C  A VALUE FOR THE LONGITUDE OF THE SUN 'SUNL' (RAD) IN THE ECLIPTIC.
C  'DAY' IS MJD2000.  SIMPLIFIED FORMULA FROM SUBROUTINE 'SOLUNA'.
C    SUNM = XLSUNA + XLSUNB*DAY
C    SUNL = SUNM + ECLECC*DSIN(SUNM - ECLOM)
C
C  NB: XLSUNA IS NEGATIVE, WHICH IS USED IN SOME ORBLIB ROUTINES TO
C  DISTINGUISH THE NEW SYSTEM, WITH COOT20, FROM THE OLD, WITH COOT.
      XLSUNA =-1.396732959 D0
      XLSUNB = 0.1720279155D-01
      ECLECC = 335.D-4
      ECLOM = 4.938244359D0
C
C  TWICE*ROTATION FROM PRECESSION OF MEAN SYSTEM OF DATE FROM SUBROUTINE
C  'PR2000'.  THE CORIOLIS ACCELERATION IN KM/SEC**2 ON A SPACECRAFT
C  WITH VELOCITY = (VX,VY,VZ) KM/SEC IS OBTAINED BY:
C  ACC = ( -PRACCY*VY - PRACCZ*VZ , PRACCY*VX , PRACCZ*VX)
      PRACCY = 1.4172 D-11
      PRACCZ = 0.6158 D-11
      RETURN
      END
#__mcat: debug.F     **DO NOT DELETE
      SUBROUTINE DEBUG(NAME,BDEB,ACTIVE)
C
C     THE ROUTINE RETURNS BDEB=.TRUE. IF NAME
C     OCCURS IN DEBUG-FILE....
C     ...This routine was inspired by Lars Behrend's RUNPAR debug system...
C
      IMPLICIT NONE
      SAVE
C
      CHARACTER*8 NAME
      LOGICAL*4 BDEB
C
      LOGICAL*4 FIRST,FOPEN,OK,ENTER,DONE,ACTIVE
      DATA FIRST /.TRUE./
      DATA FOPEN /.FALSE./
      DATA ENTER /.FALSE./
      DATA DONE /.FALSE./
      CHARACTER*8 MYNAME
      DATA MYNAME /'DEBUG'/
C
      INTEGER*4 NRNAME,MXNAME,LINE,II,IRC
      PARAMETER (MXNAME=100)
      CHARACTER*8 NAMES(MXNAME)
      DATA NRNAME /0/
      CHARACTER*80 PATHF,IPATHF
      DATA PATHF /'debug.txt'/
C
      INTEGER*4 FTUNIT,UNITI
      EXTERNAL FTUNIT
C
      INTEGER*4 NRHDR,NRDAT
      PARAMETER (NRHDR=100,NRDAT=1)
      CHARACTER*100 HDR100(NRHDR),DAT100
      INTEGER*4 INTOUT
      LOGICAL*4 ENDOFF
C
      INTEGER*4 LENGTH,LENH,LEND,LENS,LENP,KODE
      EXTERNAL LENGTH
C
      LOGICAL*4 ALL(2),SPEC
      DATA ALL /.FALSE.,.FALSE./
      DATA SPEC /.FALSE./
C
C     ONLY EXECUTE THIS ROUTINE IF IT HAS NOT BEEN ENTERED...
C     ...OR IF IT HAS BEEN RUN THROUGH COMPLETELY...
C     ...(AVVOID LOOPS SINCE THE ROUTINE CALLS OTHER ROUTINES ...
C     ...THAT CALL THIS ROUTINE)...
C
      BDEB=.FALSE.
      ACTIVE=DONE
      IF (ENTER.AND..NOT.DONE) RETURN
C
      ENTER=.TRUE.
C
      IF (FIRST) THEN
C
C     OPEN FILE AND READ NAMES
C
         UNITI=FTUNIT(IRC)
         IF (IRC.NE.0) THEN
            WRITE(*,*) MYNAME,'Error return from FTUNIT.',IRC
            RETURN
         ENDIF
         OPEN(UNIT=UNITI,FILE=PATHF,
     &        ACCESS='SEQUENTIAL',FORM='FORMATTED',
     &        STATUS='OLD',ERR=999)
C
         FOPEN=.TRUE.
C
         HDR100(1)='DEBUG V1.0[0]VFMLR'
         HDR100(2)='PRINT DEBUG DATA FOR THE ROUTINES : [*]VFR'
         HDR100(3)='PRINT DEBUG DATA FOR ALL ROUTINES, '//
     &        'EXCEPT : [*]VFR'
         IRC=0
C     
C     READ DATA FROM INPUT FILE..............................
C     
         KODE=-1
         CALL NUKEM(KODE,UNITI,HDR100,INTOUT,DAT100,ENDOFF,IRC)
         IF (IRC.NE.0) THEN
            WRITE(*,*) MYNAME,'Error return from NUKEM.'
            RETURN
         END IF
         LINE=INTOUT
C     
         KODE=0
         DO WHILE (.NOT.ENDOFF)
C     
C     READ NEXT DATA LINE
C     
            CALL NUKEM(KODE,UNITI,HDR100,INTOUT,DAT100,ENDOFF,IRC)
            IF (IRC.NE.0) THEN
               WRITE(*,*) MYNAME,'Error return from NUKEM.'
               RETURN
            END IF
            LINE=INTOUT
C
            IF (LINE.EQ.1) THEN
C     WE JUST READ 'DEBUG V1.0'
            ELSEIF (LINE.EQ.2.AND..NOT.ALL(2)) THEN
C     WE JUST READ 'PRINT DEBUG DATA FOR THE ROUTINES :'
               SPEC=.TRUE.
               ALL(1)=.TRUE.
               IF (NRNAME.LT.MXNAME) NRNAME=NRNAME+1
               LEND=LENGTH(DAT100,100,LEND)
               NAMES(NRNAME)=DAT100(1:LEND)
            ELSEIF (LINE.EQ.3.AND..NOT.ALL(1)) THEN
C     WE JUST READ 'PRINT DEBUG DATA FOR ALL ROUTINES, EXCEPT :'
               SPEC=.TRUE.
               ALL(2)=.TRUE.
               IF (NRNAME.LT.MXNAME) NRNAME=NRNAME+1
               LEND=LENGTH(DAT100,100,LEND)
               NAMES(NRNAME)=DAT100(1:LEND)
            ELSE IF (LINE.NE.0) THEN ! LINE.EQ.0 IMPLIES SOMETIMES EOF
               WRITE(*,*) MYNAME,
     &              'System error, line not implemented:',LINE
               IRC=999
               RETURN
            ENDIF
         ENDDO
C
         KODE=1
         CALL NUKEM(KODE,UNITI,HDR100,INTOUT,DAT100,ENDOFF,IRC)
         IF (IRC.NE.0) THEN
            WRITE(*,*) MYNAME,'Error return from NUKEM.'
            RETURN
         END IF
C     
         CLOSE(UNITI)
C
         FOPEN=.TRUE.
         GOTO 1000
 999     CONTINUE
         CALL CHOP(PATHF,80)
         LENP=LENGTH(PATHF,80,LENP)
         WRITE(*,*) MYNAME,'unable to read debug file : ',
     &        PATHF(1:LENP)
         FOPEN=.FALSE.
 1000    CONTINUE
C
         FIRST=.FALSE.
      ENDIF
C
      IF (FOPEN) THEN
C
C     CHECK IF NAME IS IN NAMES
C
         DO II=1,NRNAME
            IF (.NOT.BDEB) BDEB=(NAMES(II).EQ.NAME)
C     WRITE(*,*) MYNAME,NAME,NAMES(II),BDEB
         ENDDO
C
         IF (ALL(2)) BDEB=(.NOT.BDEB)
C
      ENDIF
C
      DONE=.TRUE.
      ACTIVE=DONE
C
      RETURN
C
      ENTRY DEBINT(IPATHF)
C
C     SET FILE NAME
C
      PATHF=IPATHF
C
      RETURN
      END
#__mcat: defntnr.F     **DO NOT DELETE
      LOGICAL*4 FUNCTION DEFNTNR(CHAR,CODE,NEED)
C
C     RETURNS FALSE IF THE STRING WE ARE READING DEFINITELY IS NOT A NUMBER
C
C     CHAR (C*1) THE NEXT CHARACTER
C     CODE =+1 INITIALISE TO GO FORWARDS
C     CODE =-1 INITIALISE TO GO BACKWARDS
C     CODE =+1 CHECK CURRENT CHARACTER
C     NEED = .TRUE. IF WE NEED AT LEAST ONE MORE CHARACTER
C
      IMPLICIT NONE
      SAVE
C
      CHARACTER*1 CHAR
      INTEGER*4 CODE
      LOGICAL*4 NEED
C
      INTEGER*4 ICODE
      CHARACTER*8 MYNAME
      DATA MYNAME /'DEFNTNR'/
      DATA ICODE /0/
C
      INTEGER*4 JJ,
     &     POSSG,POSNR,POSDE,POSDD,
     &     NRSGN,NRNRR,NRDES,NRDDE
      LOGICAL*4 QREAL,OQREAL,DIGIT
      EXTERNAL DIGIT
C
      LOGICAL*4 OUT
C
      IF (CODE.EQ.-1.OR.CODE.EQ.1)THEN
         ICODE=CODE
         QREAL=.TRUE.
         OQREAL=.FALSE.
         NEED=.FALSE.
C
         POSSG=0
         POSNR=0
         POSDE=0
         POSDD=0
C
         NRSGN=0
         NRNRR=0
         NRDES=0
         NRDDE=0
C
         JJ=1000
C
         CODE=0
C
      ENDIF
C
      IF (ICODE.EQ.1)THEN
C
C     GOING FORWARDS
C
         JJ=JJ+1
         IF (QREAL) THEN
            IF (CHAR.EQ.'.') THEN
               NRDES=NRDES+1
               POSDE=JJ
               QREAL=(NRDES.LE.1.AND.NRDDE.LT.1)
               NEED=(POSDE.LE.(1+NRSGN))
            ELSEIF (CHAR.EQ.'D' .OR. CHAR.EQ.'E') THEN
               NRDDE=NRDDE+1
               POSDD=JJ
               QREAL=(NRDDE.LE.1 .AND. POSDD.GT.(NRDES+NRSGN+1))
               NEED=.TRUE.
            ELSEIF (CHAR.EQ.'-'.OR.CHAR.EQ.'+') THEN
               NRSGN=NRSGN+1
               POSSG=JJ
               QREAL=((NRSGN.LE.1.AND.POSSG.EQ.1) .OR.
     &              (NRSGN.LE.2.AND.NRDDE.EQ.1
     &              .AND.POSDD.EQ.(POSSG-1)))
               NEED=.TRUE.
            ELSE
               QREAL=(DIGIT(CHAR))
               NEED=.FALSE.
               IF (QREAL) POSNR=JJ
            ENDIF
         ENDIF
C
         OUT=QREAL
C
      ELSEIF (ICODE.EQ.-1)THEN
C
C     GOING BACKWARDS
C
         JJ=JJ-1
         IF (QREAL) THEN
            IF (CHAR.EQ.'.') THEN
               NRDES=NRDES+1
               POSDE=JJ
               QREAL=(NRDES.LE.1)
               IF (QREAL) THEN
                  QREAL=(POSDE+1.NE.POSSG)
               ENDIF
               IF (QREAL.AND.NRSGN.GT.0)
     &              QREAL=(.NOT.(POSSG.EQ.JJ+1))
            ELSEIF (CHAR.EQ.'D' .OR.
     &              CHAR.EQ.'E') THEN
               NRDDE=NRDDE+1
               POSDD=JJ
               QREAL=(NRDDE.LE.1.AND.NRDES.LT.1.AND.
     &              ((NRSGN.EQ.1.AND.POSDD+1.EQ.POSSG).OR.
     &              (NRSGN.EQ.0)))
               NEED=.TRUE.
            ELSEIF (CHAR.EQ.'-'.OR.
     &              CHAR.EQ.'+') THEN
               NRSGN=NRSGN+1
               POSSG=JJ
               QREAL=((NRSGN.EQ.1.OR.(NRSGN.EQ.2.AND.NRDDE.EQ.1))
     &              .AND.(POSSG+1.EQ.POSDE.OR.POSSG+1.EQ.POSNR))
               NEED=.FALSE.
            ELSE
               QREAL=((DIGIT(CHAR)).AND.NRSGN.LE.1)
               IF (QREAL) THEN
                  POSNR=JJ
                  QREAL=(POSNR+1.NE.POSSG)
               ENDIF
               NEED=.FALSE.
            ENDIF
         ENDIF
C
         OUT=QREAL
C
      ELSE
         WRITE(*,*) MYNAME,'CODE UNKNOWN',CODE,'.'
      ENDIF
C
      DEFNTNR=OUT
      RETURN
      END
#__mcat: digit.F     **DO NOT DELETE
      LOGICAL*4 FUNCTION DIGIT(STRING)
C     ***********************************************************************
C     +                                                                     *
C     CHECKS IF STRING IS A DIGIT                                           *
C     +                                                                     *
CI    STRING (C*1) = STRING TO BE EXAMINED                                  *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      CHARACTER*1 STRING
C
      LOGICAL*4 BUFF
C
      BUFF= (  STRING.EQ.'0' .OR.
     &     STRING.EQ.'1' .OR.
     &     STRING.EQ.'2' .OR.
     &     STRING.EQ.'3' .OR.
     &     STRING.EQ.'4' .OR.
     &     STRING.EQ.'5' .OR.
     &     STRING.EQ.'6' .OR.
     &     STRING.EQ.'7' .OR.
     &     STRING.EQ.'8' .OR.
     &     STRING.EQ.'9')
C
      DIGIT=BUFF
C
      RETURN
      END
#__mcat: dj2000.F     **DO NOT DELETE
      SUBROUTINE DJ2000(DAY,YY,MM,DD,HH,MI,SEC)
CP  COMPUTES CALENDER DATE FROM MODIFIED JULIAN DAY 2000
C   VALID FOR DATES BETWEEN 1950/JAN/1 AND 2099/DEC/31.
C
C   MJD(2000) = MJD(1950) - 18262.0 IS = 0 ON 2000/01/01 AT 00:00:00.
C
CI  (REAL*8) DAY = MOD. JUL. DAY, REFERRED TO 2000.
CO  (INT*4) YY = YEAR WITH 4 DIGITS
CO  (INT*4) MM = MONTH
CO  (INT*4) DD = DAY
CO  (INT*4) HH = HOUR
CO  (INT*4) MI = MINUTE
CO  (REAL*8) SEC = SECOND.
C
      IMPLICIT NONE
      SAVE
C
      CHARACTER*40 SCCS_INFO
      DATA SCCS_INFO
     & /'@(#)dj2000.f \n'/
C
      REAL*8 DAY, SEC
      INTEGER*4 YY,MM,DD,HH,MI
C
      INTEGER*4 JDAY,JJ,KK,LL,NN
C
C  MAKE SURE TO ROUND-OFF ONLY DOWN, ALSO FOR NEGATIVE MJD:
      JDAY = DAY + 18262.D0
      JJ = (4000*(JDAY + 18204))/1461001
      KK = JDAY - (1461*JJ)/4 + 18234
      LL = (80*KK)/2447
      DD = KK - (2447*LL)/80
      NN = LL/11
      MM = LL + 2 - 12*NN
      YY = 1900 + JJ + NN
      SEC = (DAY - DFLOAT(JDAY-18262))*24.D0
      HH = SEC
      SEC = (SEC - DFLOAT(HH))*6.D1
      MI = SEC
      SEC = (SEC - DFLOAT(MI))*6.D1
      RETURN
      END
#__mcat: eval.F     **DO NOT DELETE
      SUBROUTINE EVAL(STRING,N,NRVAR,NAMVAR,VALVAR,VARLEN,
     &     LFL,IRC)
C     ***********************************************************************
C     +                                                                     *
C     EVALUATES AN EXPRESSION                                               *
C     +                                                                     *
CIO   STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    N (I*4) = LENGTH OF STRING                                            *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N
      CHARACTER*(*) STRING
      INTEGER*4 NRVAR
      CHARACTER*100 NAMVAR(NRVAR),VALVAR(NRVAR)
      INTEGER*4 VARLEN(NRVAR),IRC
C
      INTEGER*4 II,CNT,LENS,LENGTH
      EXTERNAL LENGTH
      LOGICAL*4 BDEB,ACTIVE
      DATA ACTIVE /.FALSE./
      LOGICAL*4 CHANGED,CHNG(5),LFL(5)
      CHARACTER*8 MYNAME
      DATA MYNAME /'EVAL'/
C
C     Debug System.
C
      IF (.NOT.ACTIVE) CALL DEBUG(MYNAME,BDEB,ACTIVE)
C
      IF (BDEB) WRITE(*,*) MYNAME,'Debug: Routine starts.',IRC
C
C-----REMOVE UNNECCESARY BLANKS
C
      CALL CHOP(STRING,N)
C
      IF (BDEB) THEN
         LENS=LENGTH(STRING,N,0)
         WRITE(*,*) MYNAME,'Debug:',(STRING(II:II),II=1,LENS)
      ENDIF
C
C-----INITIALISE
C
      CNT=0
      IRC=0
      CHANGED=.TRUE.
      DO WHILE(CHANGED)
C
C------VARIABLE SUBSTITUTION
C
         IF (LFL(1)) CALL EVALV(STRING,N,NRVAR,NAMVAR,VALVAR,VARLEN,
     &        CHNG(1),IRC)
         IF (IRC.NE.0) RETURN
C
C------FUNCTION EVALUATION
C
         IF (LFL(2)) CALL EVALF(STRING,N,CHNG(2),IRC)
         IF (IRC.NE.0) RETURN
C
C------MATHEMATICAL PROCESSING
C
         IF (LFL(3)) CALL EVALM(STRING,N,CHNG(3),IRC)
         IF (IRC.NE.0) RETURN
C
C------LOGICAL OPERATIONS
C
         IF (LFL(4)) CALL EVALL(STRING,N,CHNG(4),IRC)
         IF (IRC.NE.0) RETURN
C
C------RECURSIVE PROCESSING
C
         CHANGED=.FALSE.
         DO II=1,4
            IF(CHNG(II).AND.LFL(II)) CHANGED=LFL(5)
         ENDDO
C
C------UPDATE COUNTER AND MAKE SURE WE DON'T LOOP FOREVER
C
         IF (CNT.LT.100) THEN
            CNT=CNT+1
         ELSE
            IRC=999
            CHANGED=.FALSE.
            WRITE(*,*) MYNAME,'Error: recursive variable call.'
         ENDIF
      ENDDO
C
      IF (BDEB) WRITE(*,*) MYNAME,'Debug: Routine ends.',IRC
C
      RETURN
      END
#__mcat: evalf.F     **DO NOT DELETE
      SUBROUTINE EVALF(STRING,N,CHANGED,IRC)
C     ***********************************************************************
C     +                                                                     *
C     EVALUATES AN EXPRESSION                                               *
C     +                                                                     *
CIO   STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    N (I*4) = LENGTH OF STRING                                            *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N,IRC
      CHARACTER*(*) STRING
      LOGICAL*4 CHANGED
C
      CHANGED=.FALSE.
C
C-----PERFORM ALL MATHEMATICAL OPERATIONS
C
      CALL PERFF(STRING,N,CHANGED,IRC)
C
C-----CLEAN UP
C
      CALL CHOP(STRING,N)
      CALL CLEANUP(STRING,N)
C
      RETURN
      END
#__mcat: evall.F     **DO NOT DELETE
      SUBROUTINE EVALL(STRING,N,CHANGED,IRC)
C     ***********************************************************************
C     +                                                                     *
C     EVALUATES AN EXPRESSION                                               *
C     +                                                                     *
CIO   STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    N (I*4) = LENGTH OF STRING                                            *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N,IRC
      CHARACTER*(*) STRING
      LOGICAL*4 CHANGED
C
      CHANGED=.FALSE.
C
C-----PERFORM ALL LOGICAL OPERATIONS
C
      CALL PERFL(STRING,N,CHANGED,IRC)
C
C-----CLEAN UP
C
      CALL CHOP(STRING,N)
      CALL CLEANUP(STRING,N)
C
      RETURN
      END
#__mcat: evalm.F     **DO NOT DELETE
      SUBROUTINE EVALM(STRING,N,CHANGED,IRC)
C     ***********************************************************************
C     +                                                                     *
C     EVALUATES AN EXPRESSION                                               *
C     +                                                                     *
CIO   STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    N (I*4) = LENGTH OF STRING                                            *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N,IRC
      CHARACTER*(*) STRING
      LOGICAL*4 CHANGED
C
      CHANGED=.FALSE.
C
C-----PERFORM ALL MATHEMATICAL OPERATIONS
C
      CALL PERFM(STRING,N,CHANGED,IRC)
C
C-----CLEAN UP
C
      CALL CHOP(STRING,N)
      CALL CLEANUP(STRING,N)
      CALL TRUNC0(STRING,N)
C
      RETURN
      END
#__mcat: evalv.F     **DO NOT DELETE
      SUBROUTINE EVALV(STRING,N,NRVAR,NAMVAR,VALVAR,VARLEN,CHANGED,IRC)
C     ***********************************************************************
C     +                                                                     *
C     EVALUATES AN EXPRESSION                                               *
C     +                                                                     *
CIO   STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    N (I*4) = LENGTH OF STRING                                            *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N
      CHARACTER*(*) STRING
      INTEGER*4 NRVAR
      CHARACTER*100 NAMVAR(NRVAR),VALVAR(NRVAR)
      INTEGER*4 VARLEN(NRVAR),IRC
C
      INTEGER*4 II,JJ,KK,CNT,VALLEN,
     &     LENS,LENB,LENGTH
      EXTERNAL LENGTH
      LOGICAL*4 CHANGED,EQUAL,DONE,ATOM,QQ(2)
      EXTERNAL ATOM
      REAL*8 RR(2)
      CHARACTER*100 BUFF,BUFF1
      INTEGER*4 START,END,CPOS
C
      CHARACTER*8 MYNAME
      DATA MYNAME /'EVALV'/
C
      CNT=0
      IRC=0
      CHANGED=.FALSE.
C
C     SEARCH FOR A '$'-SIGN IN STRING
C
      II=0
      LENS=LENGTH(STRING,N,LENS)
      DO WHILE(II.LT.LENS)
         II=II+1
         IF (STRING(II:II).EQ.'$') THEN
C     FIND FOLLOWING OBJECT
            QQ(1)=.FALSE.
            QQ(2)=.FALSE.
            START=II
            CPOS=II+1
            CALL ARGUMENT(STRING,N,CPOS,BUFF1,QQ,RR)
            END=CPOS
            CALL CHOP (BUFF1,100)
            LENB=LENGTH(BUFF1,100,LENB)
C     CHECK FOR HELP
            IF (LENB.EQ.1.AND.BUFF1(1:1).EQ.'?') THEN
               IF (NRVAR.GT.0) THEN
                  WRITE(*,*) MYNAME,
     &                 '--------LIST OF CURRENT VARIABLES-------'
                  DO KK=1,NRVAR
                     VALLEN=LENGTH(VALVAR(KK),100,VALLEN)
                     WRITE(*,*) '$(',NAMVAR(KK)(1:VARLEN(KK))//') = '//
     &                    VALVAR(KK)(1:VALLEN)
                  ENDDO
                  WRITE(*,*) MYNAME,
     &                 '----------------------------------------'
               ELSE
                  WRITE(*,*) MYNAME,
     &                 '----------------------------------------'
                  WRITE(*,*) 'No variables have been defined.'
                  WRITE(*,*) MYNAME,
     &                 '----------------------------------------'
               ENDIF
               CALL RESET(BUFF,100)
               WRITE(BUFF,*) NRVAR
               CALL CHOP(BUFF,100)
               LENB=LENGTH(BUFF,100,LENB)
               CALL SUBSTR(STRING,N,BUFF,LENB,START,END-START+1)
               CHANGED=.TRUE.
               JJ=NRVAR
C
            ENDIF
C     CHECK IF VARIABLE IS DEFINED
            JJ=0
            DO WHILE (JJ.LT.NRVAR.AND..NOT.CHANGED)
               JJ=JJ+1
               KK=1
               DONE=(VARLEN(JJ).EQ.0.OR.VARLEN(JJ).NE.LENB)
               EQUAL=.NOT.DONE
               DO WHILE (.NOT.DONE)
                  IF (EQUAL.AND.KK.LE.VARLEN(JJ)) THEN
                     EQUAL=(BUFF1(KK:KK).EQ.
     &                    NAMVAR(JJ)(KK:KK))
                     KK=KK+1
                  ELSE
                     DONE=.TRUE.
                  ENDIF
               ENDDO
               IF (EQUAL) THEN
C     REPLACE VARIABLE WITH EXPRESSION
                  VALLEN=LENGTH(VALVAR(JJ),100,VALLEN)
                  CALL RESET(BUFF,100)
                  BUFF=VALVAR(JJ)(1:VALLEN)
                  CALL CHOP(BUFF,100)
                  LENB=LENGTH(BUFF,100,LENB)
                  CALL SUBSTR(STRING,N,BUFF,LENB,START,END-START+1)
C     IN CASE THE EXPRESSION STARTS WITH A NEW VARIABLE
                  II=II-1
C
                  CHANGED=.TRUE.
                  JJ=NRVAR
C
               ENDIF
            ENDDO
         ENDIF
      ENDDO
C
C
      RETURN
      END
#__mcat: execf.F     **DO NOT DELETE
      SUBROUTINE EXECF(STRING,N,CHANGED,POS)
C     ***********************************************************************
C     +                                                                     *
C     EVALUATES AN EXPRESSION                                               *
C     +                                                                     *
CIO   STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    N (I*4) = LENGTH OF STRING                                            *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N,IRC,POS(2)
      CHARACTER*1 STRING(N)
      LOGICAL*4 CHANGED
C
      CHARACTER*100 BUFF,BUFF1
      CHARACTER*24 fdate
      EXTERNAL fdate
C
      INTEGER*4 II,JJ,KK,CNT,FTUNIT,
     &     LENB,LENH,LENGTH
      EXTERNAL LENGTH,FTUNIT
      LOGICAL*4 EQUAL,DONE,QQ(2),ISINT,ISREAL,LCHNG
      EXTERNAL ISINT,ISREAL
      INTEGER*4 START,END,CPOS,UNITT,
     &     IY,IM,ID,IH,IMM
C
      INTEGER*4 NRFUNK
      PARAMETER (NRFUNK=19)
      CHARACTER*20 FUNK20(NRFUNK),FUNH20(NRFUNK)
      INTEGER*4 FUNKLEN(NRFUNK)
      REAL*8 PI,E,XMU,RE,RAD,DEG,RRR(2),RR,SEC,TIME
      LOGICAL*4 FIRST
      DATA FIRST /.TRUE./
C
      CHARACTER*8 MYNAME
      DATA MYNAME /'EXECF'/
C
      IF (FIRST) THEN
C
C     DEFINE AUXILIARY FUNCTIONS
C
         FUNK20(1)='%sin'
         FUNH20(1)='(<number>)'
         FUNK20(2)='%cos'
         FUNH20(2)='(<number>)'
         FUNK20(3)='%tan'
         FUNH20(3)='(<number>)'
         FUNK20(4)='%arcsin'
         FUNH20(4)='(<number>)'
         FUNK20(5)='%arccos'
         FUNH20(5)='(<number>)'
         FUNK20(6)='%arctan'
         FUNH20(6)='(<number>)'
         FUNK20(7)='%log'
         FUNH20(7)='(<number>)'
         FUNK20(8)='%exp'
         FUNH20(8)='(<number>)'
         FUNK20(9)='%inquire'
         FUNH20(9)='(<file>)'
         FUNK20(10)='%pi'
         CALL RESET(FUNH20(10),20)
         FUNK20(11)='%e'
         CALL RESET(FUNH20(11),20)
         FUNK20(12)='%mu'
         CALL RESET(FUNH20(12),20)
         FUNK20(13)='%re'
         CALL RESET(FUNH20(13),20)
         FUNK20(14)='%rad'
         CALL RESET(FUNH20(14),20)
         FUNK20(15)='%deg'
         CALL RESET(FUNH20(15),20)
         FUNK20(16)='%dj2000'
         FUNH20(16)='(<date>)'
         FUNK20(17)='%jd2000'
         FUNH20(17)='(<MJD2000>)'
         FUNK20(18)='%?'
         CALL RESET(FUNH20(18),20)
         FUNK20(19)='%date'
         CALL RESET(FUNH20(19),20)
C
         PI=2.0D0*DATAN2(1.0D0,0.0D0)
         E=2.718281828459045D0
         XMU=398600.440D0
         RE=6378.136D0
         RAD=PI/180.0D0
         DEG=180.0D0/PI
C
         DO II=1,NRFUNK
            CALL CHOP(FUNK20(II),20)
            FUNKLEN(II)=LENGTH(FUNK20(II),20,4)
         ENDDO
C
         FIRST=.FALSE.
      ENDIF
C
      CNT=0
      IRC=0
      CHANGED=.FALSE.
C
C
C     SEARCH FOR A '%'-SIGN IN STRING
C
      II=POS(1)
      DO WHILE(II.LT.POS(2))
         IF (STRING(II).EQ.'%') THEN
C     FIND FOLLOWING OBJECT
            QQ(1)=.FALSE.
            QQ(2)=.FALSE.
            START=II
            CPOS=II+1
            CALL ARGUMENT(STRING,N,CPOS,BUFF1,QQ,RR)
            END=CPOS
            CALL CEQUAL(BUFF1,100,STRING,START,END)
            CALL CHOP(BUFF1,100)
            LENB=LENGTH(BUFF1,100,LENB)
C     CHECK IF FUNCTION IS DEFINED
            JJ=0
            DO WHILE (JJ.LT.NRFUNK.AND..NOT.CHANGED)
               JJ=JJ+1
               KK=1
               DONE=(FUNKLEN(JJ).EQ.0.OR.FUNKLEN(JJ).NE.LENB)
               EQUAL=.NOT.DONE
               DO WHILE (.NOT.DONE)
                  IF (EQUAL.AND.KK.LE.FUNKLEN(JJ)) THEN
                     EQUAL=(BUFF1(KK:KK).EQ.
     &                    FUNK20(JJ)(KK:KK))
                     KK=KK+1
                  ELSE
                     DONE=.TRUE.
                  ENDIF
               ENDDO
               IF (EQUAL) THEN
C
                  CALL RESET(BUFF,100)
                  LCHNG=.FALSE.
                  IF (JJ.EQ.1) THEN
C     %sin
                     QQ(1)=.TRUE.
                     QQ(2)=.FALSE.
                     CPOS=END+1
                     CALL ARGUMENT(STRING,N,CPOS,BUFF1,QQ,RRR)
                     END=CPOS
                     IF (QQ(1)) THEN
                        RR=DSIN(RRR(1))
                        WRITE(BUFF,*) RR
                        LCHNG=.TRUE.
                     ENDIF
                  ELSEIF (JJ.EQ.2) THEN
C     %cos
                     QQ(1)=.TRUE.
                     QQ(2)=.FALSE.
                     CPOS=END+1
                     CALL ARGUMENT(STRING,N,CPOS,BUFF1,QQ,RRR)
                     END=CPOS
                     IF (QQ(1)) THEN
                        RR=DCOS(RRR(1))
                        WRITE(BUFF,*) RR
                        LCHNG=.TRUE.
                     ENDIF
                  ELSEIF (JJ.EQ.3) THEN
C     %tan
                     QQ(1)=.TRUE.
                     QQ(2)=.FALSE.
                     CPOS=END+1
                     CALL ARGUMENT(STRING,N,CPOS,BUFF1,QQ,RRR)
                     END=CPOS
                     IF (QQ(1)) THEN
                        RR=DTAN(RRR(1))
                        WRITE(BUFF,*) RR
                        LCHNG=.TRUE.
                     ENDIF
                  ELSEIF (JJ.EQ.4) THEN
C     %arcsin
                     QQ(1)=.TRUE.
                     QQ(2)=.FALSE.
                     CPOS=END+1
                     CALL ARGUMENT(STRING,N,CPOS,BUFF1,QQ,RRR)
                     END=CPOS
                     IF (QQ(1)) THEN
                        RR=DASIN(RRR(1))
                        WRITE(BUFF,*) RR
                        LCHNG=.TRUE.
                     ENDIF
                  ELSEIF (JJ.EQ.5) THEN
C     %arccos
                     QQ(1)=.TRUE.
                     QQ(2)=.FALSE.
                     CPOS=END+1
                     CALL ARGUMENT(STRING,N,CPOS,BUFF1,QQ,RRR)
                     END=CPOS
                     IF (QQ(1)) THEN
                        RR=DACOS(RRR(1))
                        WRITE(BUFF,*) RR
                        LCHNG=.TRUE.
                     ENDIF
                  ELSEIF (JJ.EQ.6) THEN
C     %arctan
                     QQ(1)=.TRUE.
                     QQ(2)=.TRUE.
                     CPOS=END+1
                     CALL ARGUMENT(STRING,N,CPOS,BUFF1,QQ,RRR)
                     END=CPOS
                     IF (QQ(1).AND.QQ(2)) THEN
                        RR=DATAN2(RRR(1),RRR(2))
                        WRITE(BUFF,*) RR
                        LCHNG=.TRUE.
                     ELSEIF (QQ(1)) THEN
                        RR=DATAN(RRR(1))
                        WRITE(BUFF,*) RR
                        LCHNG=.TRUE.
                     ENDIF
                  ELSEIF (JJ.EQ.7) THEN
C     %log
                     QQ(1)=.TRUE.
                     QQ(2)=.FALSE.
                     CPOS=END+1
                     CALL ARGUMENT(STRING,N,CPOS,BUFF1,QQ,RRR)
                     END=CPOS
                     IF (QQ(1)) THEN
                        RR=DLOG(RRR(1))
                        WRITE(BUFF,*) RR
                        LCHNG=.TRUE.
                     ENDIF
                  ELSEIF (JJ.EQ.8) THEN
C     %exp
                     QQ(1)=.TRUE.
                     QQ(2)=.FALSE.
                     CPOS=END+1
                     CALL ARGUMENT(STRING,N,CPOS,BUFF1,QQ,RRR)
                     END=CPOS
                     IF (QQ(1)) THEN
                        RR=DEXP(RRR(1))
                        WRITE(BUFF,*) RR
                        LCHNG=.TRUE.
                     ENDIF
                  ELSEIF (JJ.EQ.9) THEN
C     %inquire
                     QQ(1)=.FALSE.
                     QQ(2)=.FALSE.
                     CPOS=END+1
                     CALL ARGUMENT(STRING,N,CPOS,BUFF1,QQ,RRR)
                     END=CPOS
                     LENB=LENGTH(BUFF1,100,LENB)
                     UNITT=FTUNIT(IRC)
                     IF (IRC.NE.0) THEN
                        WRITE(*,*) MYNAME,'Error return from DEBUG.',
     &                       IRC
                        RETURN
                     ENDIF
C     DON'T DO ANYTHING IF THE FILE DOES NOT EXIST...
C     ...(IT MAY NEED YET SOME VARIABLE REPLACEMENTS)
                     OPEN(UNIT=UNITT,FILE=BUFF1,
     &                    STATUS='OLD',ERR=999)
                     CLOSE (UNIT=UNITT)
                     CALL RESET(BUFF,100)
                     BUFF='T'
                     LCHNG=.TRUE.
                     JJ=NRFUNK
 999                 CONTINUE
                  ELSEIF (JJ.EQ.10) THEN
C     %pi
                     WRITE(BUFF,*) PI
                     LCHNG=.TRUE.
                  ELSEIF (JJ.EQ.11) THEN
C     %e
                     WRITE(BUFF,*) E
                     LCHNG=.TRUE.
                  ELSEIF (JJ.EQ.12) THEN
C     %mu
                     WRITE(BUFF,*) XMU
                     LCHNG=.TRUE.
                  ELSEIF (JJ.EQ.13) THEN
C     %re
                     WRITE(BUFF,*) RE
                     LCHNG=.TRUE.
                  ELSEIF (JJ.EQ.14) THEN
C     %rad
                     WRITE(BUFF,*) RAD
                     LCHNG=.TRUE.
                  ELSEIF (JJ.EQ.15) THEN
C     %deg
                     WRITE(BUFF,*) DEG
                     LCHNG=.TRUE.
                  ELSEIF (JJ.EQ.16) THEN
C     %dj2000
                     QQ(1)=.TRUE.
                     QQ(2)=.FALSE.
                     CPOS=END+1
                     CALL ARGUMENT(STRING,N,CPOS,BUFF1,QQ,RRR)
                     END=CPOS
                     LENB=LENGTH(BUFF1,100,LENB)
                     IF (QQ(1)) THEN
                        CALL DJ2000(RRR(1),IY,IM,ID,IH,IMM,SEC)
                        WRITE(BUFF,'(I4,X,4(I2,X),F6.3)')
     &                       IY,IM,ID,IH,IMM,SEC
                        LCHNG=.TRUE.
                     ENDIF
                  ELSEIF (JJ.EQ.17) THEN
C     %jd2000
                     QQ(1)=.FALSE.
                     QQ(2)=.FALSE.
                     CPOS=END+1
                     CALL ARGUMENT(STRING,N,CPOS,BUFF1,QQ,RRR)
                     END=CPOS
                     LENB=LENGTH(BUFF1,100,LENB)
                     CALL NUKECP(BUFF1,'/',' ',LENB)
                     CALL NUKECP(BUFF1,':',' ',LENB)
                     READ(BUFF1(1:LENB),*,END=201,ERR=201)
     &                    IY,IM,ID,IH,IMM,SEC
                     CALL JD2000(TIME,IY,IM,ID,IH,IMM,SEC)
                     WRITE(BUFF,*) TIME
                     LCHNG=.TRUE.
 201                 CONTINUE
                  ELSEIF (JJ.EQ.18) THEN
C     %?
                     WRITE(*,*) MYNAME,
     &                    '--------LIST OF POSSIBLE FUNCTIONS------'
                     DO II=1,NRFUNK
                        LENB=LENGTH(FUNK20(II),20,3)
                        LENH=LENGTH(FUNH20(II),20,3)
                        WRITE(*,*) FUNK20(II)(1:LENB)//' '//
     &                       FUNH20(II)(1:LENH)
                     ENDDO
                     WRITE(*,*) MYNAME,
     &                    '----------------------------------------'
                     CALL RESET(BUFF,100)
                     LCHNG=.TRUE.
                  ELSEIF (JJ.EQ.19) THEN
C     %date
                     CALL RESET(BUFF,100)
                     BUFF(1:24)=fdate()
                     LCHNG=.TRUE.
                  ENDIF
                  IF (LCHNG) THEN
                     CALL CHOP(BUFF,100)
                     LENB=LENGTH(BUFF,100,LENB)
                     CALL SUBSTR(STRING,N,BUFF,LENB,
     &                    START,END-START+1)
                     CHANGED=.TRUE.
                     JJ=NRFUNK
                  ENDIF
               ENDIF
            ENDDO
         ENDIF
         II=II+1
      ENDDO
C
      RETURN
      END
#__mcat: execl.F     **DO NOT DELETE
      SUBROUTINE EXECL(STRING,N,CHANGED,POS)
C     ***********************************************************************
C     +                                                                     *
C     EXECUTES (EVALUATES) A SUBSTRING OF STRING                            *
C     +                                                                     *
CIO   STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    N (I*4) = LENGTH OF STRING                                            *
CI    POS(2) (I*4) = START AND END POSITION OF SUBSTRING TO EVALUATE        *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N,POS(2)
      LOGICAL*4 CHANGED
      CHARACTER*1 STRING(N),BUFF(1000)
      CHARACTER*100 BUFF1,BUFF2,BUFF3
C
      INTEGER*4 MAXO,OPOS(2,2)
      LOGICAL*4 LCHNG
      PARAMETER(MAXO=100)
      INTEGER*4 LENGTH,LENB1,LENB2,LENB3,
     &     LENX,LENB,LENS,
     &     DELL,IRC,CPOS,
     &     BPOS(MAXO,2),MAXB,
     &     CODE,START,END,II,JJ,KK,LEVEL
      EXTERNAL LENGTH
      LOGICAL*4 FIRST,CLEAN,LAST,DONE,FOUND
      INTEGER*4 NROP
      PARAMETER(NROP=9)
      CHARACTER*2 COP(NROP)
      INTEGER*4 IOP(NROP)
      DATA FIRST /.TRUE./
C
      IF (FIRST)THEN
C
C     DEFINITION OF OPERATION STRING
C
         COP(1)='=='
         COP(2)='>='
         COP(3)='<='
         COP(4)='<>'
         COP(5)='>'
         COP(6)='<'
         COP(7)='!'
         COP(8)='&&'
         COP(9)='||'
C
C     LENGTH OF OPERATION STRING
C
         DO II=1,NROP
            CALL CHOP(COP(II),2)
            IOP(II)=LENGTH(COP(II),2,1)
         ENDDO
C
         FIRST=.FALSE.
      ENDIF
C
      LENS=LENGTH(STRING,N,LENS)
      LENB=LENGTH(BUFF,1000,LENB)
C
      LENX=MAX(LENS,LENB)
      LENX=MIN(LENX,1000)
C
      CALL CEQUAL(BUFF,LENX,STRING,POS(1)+1,POS(2)-1)
C
C     FIND ALL  SPECIAL FUNCTIONS
C
      DO KK=1,NROP
C
         CLEAN=.TRUE.
         LAST=.FALSE.
         DO WHILE (.NOT.LAST)
C
C     FIND ALL OPERATIONS
C
            LENS=LENGTH(BUFF,N,LENS)
            CALL CHOP(BUFF,LENS)
            LENS=LENGTH(BUFF,N,LENS)
C
            LEVEL=0
            MAXB=0
            II=1
            DO WHILE(II.LE.LENS)
               IF (BUFF(II).EQ.'(') LEVEL=LEVEL+1
               IF (BUFF(II).EQ.')') LEVEL=LEVEL-1
               IF (BUFF(II).EQ.'[') LEVEL=LEVEL+1
               IF (BUFF(II).EQ.']') LEVEL=LEVEL-1
               IF (BUFF(II).EQ.'{') LEVEL=LEVEL+1
               IF (BUFF(II).EQ.'}') LEVEL=LEVEL-1
               IF (LEVEL.EQ.0) THEN
                  JJ=0
                  FOUND=.TRUE.
                  DO WHILE (JJ.LT.IOP(KK).AND.
     &                 (II+JJ-1).LE.LENS.AND.FOUND)
                     JJ=JJ+1
                     FOUND=(BUFF(II+JJ-1).EQ.COP(KK)(JJ:JJ))
                  ENDDO
                  IF (FOUND.AND.(II+JJ-1).LE.LENS) THEN
                     IF (MAXB.LT.MAXO) MAXB=MAXB+1
                     BPOS(MAXB,1)=II
                     BPOS(MAXB,2)=II+IOP(KK)-1
                     II=II+IOP(KK)-1
                  ENDIF
               ENDIF
               II=II+1
            ENDDO
C
C     EXECUTE OPERATIONS
C
            DO II=1,MAXB
               CPOS=BPOS(II,2)+1
               CODE=1
               CALL OBJECT(BUFF,N,CPOS,OPOS(1,2),CODE)
               END=CPOS
C
               IF (CODE.EQ.0) THEN
C     IF WE HAD A '!', THERE MAY NOT BE ANY PRECEDING OBJECTS...
                  IF (KK.EQ.7) THEN
                     START=BPOS(II,1)
                     CALL RESET(BUFF1,100)
                  ELSE
                     CPOS=BPOS(II,1)-1
                     CODE=-1
                     CALL OBJECT(BUFF,N,CPOS,OPOS(1,1),CODE)
                     START=CPOS
                     CALL CEQUAL (BUFF1,100,BUFF,OPOS(1,1),OPOS(2,1))
                  ENDIF
                  IF (CODE.EQ.0) THEN
                     CALL CEQUAL (BUFF2,100,BUFF,OPOS(1,2),OPOS(2,2))
C
                     LENB1=LENGTH(BUFF1,100,LENB1)
                     LENB2=LENGTH(BUFF2,100,LENB2)
                     CALL CHOP(BUFF1,LENB1)
                     CALL CHOP(BUFF2,LENB1)
                     LENB1=LENGTH(BUFF1,100,LENB1)
                     LENB2=LENGTH(BUFF2,100,LENB2)
C
                     IRC=0
                     LCHNG=.FALSE.
                     CALL SLAVEL(BUFF1,BUFF2,BUFF3,KK,CLEAN,LCHNG,IRC)
                     IF (LCHNG) CHANGED=.TRUE.
                     DONE=(IRC.EQ.0)
                     IRC=0
C
                     IF (LCHNG) THEN
                        CALL CHOP(BUFF3,100)
                        LENB3=LENGTH(BUFF3,100,LENB3)
                        DELL=END-START+1
                        CALL SUBSTR(BUFF,N,BUFF3,100,START,DELL)
C
C     UPDATE POSITION OF REMAINING OPERATORS
                        LENB=LENB3-DELL
                        JJ=II+1
                        DO WHILE(JJ.LE.MAXB)
C     REMOVE JOB IF IT WAS INSIDE OTHER JOB
                           IF (BPOS(JJ,2).LE.START .OR.
     &                          BPOS(JJ,1).GT.END) THEN
                              BPOS(JJ,1)=BPOS(JJ,1)+LENB
                              BPOS(JJ,2)=BPOS(JJ,2)+LENB
                           ELSE
                              BPOS(JJ,1)=BPOS(MAXB,1)
                              BPOS(JJ,2)=BPOS(MAXB,2)
                              MAXB=MAXB-1
                              JJ=JJ-1
                           ENDIF
C     REMOVE JOB IF IT FALLS OUTSIDE BUFFER
                           IF (BPOS(JJ,2).GT.N) THEN
                              BPOS(JJ,1)=BPOS(MAXB,1)
                              BPOS(JJ,2)=BPOS(MAXB,2)
                              MAXB=MAXB-1
                              JJ=JJ-1
                           ENDIF
                           JJ=JJ+1
                        ENDDO
                     ENDIF
                  ENDIF
               ENDIF
            ENDDO
            LAST=.NOT.CLEAN
            CLEAN=.FALSE.
         ENDDO
      ENDDO
C
      CALL SUBSTR(STRING,N,BUFF,N,POS(1)+1,POS(2)-POS(1)-1)
      LENB=LENGTH(BUFF,N,LENB)
      POS(2)=POS(1)+LENB+1
C
      RETURN
      END
#__mcat: execm.F     **DO NOT DELETE
      SUBROUTINE EXECM(STRING,N,CHANGED,POS)
C     ***********************************************************************
C     +                                                                     *
C     EXECUTES (EVALUATES) A SUBSTRING OF STRING                            *
C     +                                                                     *
CIO   STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    N (I*4) = LENGTH OF STRING                                            *
CI    POS(2) (I*4) = START AND END POSITION OF SUBSTRING TO EVALUATE        *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N,POS(2)
      LOGICAL*4 CHANGED
      CHARACTER*1 STRING(N),BUFF(1000)
      CHARACTER*100 BUFF1,BUFF2,BUFF3
C
      INTEGER*4 MAXO,OPOS(2,2)
      LOGICAL*4 LCHNG
      PARAMETER(MAXO=100)
      INTEGER*4 LENGTH,LENB1,LENB2,LENB3,
     &     LENX,LENB,LENS,
     &     DELL,IRC,CPOS,
     &     BPOS(MAXO),MAXB,
     &     CODE,START,END,II,JJ,KK,LEVEL
      EXTERNAL LENGTH
      LOGICAL*4 FIRST,CLEAN,LAST,DONE
      INTEGER*4 NROP
      PARAMETER(NROP=4)
      CHARACTER*2 COP(NROP)
      INTEGER*4 IOP(NROP)
      DATA FIRST /.TRUE./
C
      IF (FIRST)THEN
C
C     DEFINITION OF OPERATION STRING
C
         COP(1)='^'
         COP(2)='*'
         COP(3)='/'
         COP(4)='+-'
C
C     LENGTH OF OPERATION STRING
C
         DO II=1,NROP
            CALL CHOP(COP(II),2)
            IOP(II)=LENGTH(COP(II),2,1)
         ENDDO
C
         FIRST=.FALSE.
      ENDIF
C
      LENS=LENGTH(STRING,N,LENS)
      LENB=LENGTH(BUFF,1000,LENB)
C
      LENX=MAX(LENS,LENB)
      LENX=MIN(LENX,1000)
C
      CALL CEQUAL(BUFF,LENX,STRING,POS(1)+1,POS(2)-1)
C
C     FIND ALL  SPECIAL FUNCTIONS
C
      DO KK=1,NROP
C
         CLEAN=.TRUE.
         LAST=.FALSE.
         DO WHILE (.NOT.LAST)
C
C     FIND ALL '*' '/' '^' '-' '+'
C
            LENS=LENGTH(BUFF,N,LENS)
            CALL CHOP(BUFF,LENS)
            LENS=LENGTH(BUFF,N,LENS)
C
            LEVEL=0
            MAXB=0
            DO II=1,LENS
               IF (BUFF(II).EQ.'(') LEVEL=LEVEL+1
               IF (BUFF(II).EQ.')') LEVEL=LEVEL-1
               IF (BUFF(II).EQ.'[') LEVEL=LEVEL+1
               IF (BUFF(II).EQ.']') LEVEL=LEVEL-1
               IF (BUFF(II).EQ.'{') LEVEL=LEVEL+1
               IF (BUFF(II).EQ.'}') LEVEL=LEVEL-1
               IF (LEVEL.EQ.0) THEN
                  DO JJ=1,IOP(KK)
                     IF (BUFF(II).EQ.COP(KK)(JJ:JJ)) THEN
                        IF (MAXB.LT.MAXO) MAXB=MAXB+1
                        BPOS(MAXB)=II
                     ENDIF
                  ENDDO
               ENDIF
            ENDDO
C
C     EXECUTE OPERATIONS
C
            DO II=1,MAXB
               CPOS=BPOS(II)+1
               CODE=1
               CALL WOBJECT(BUFF,N,CPOS,OPOS(1,2),CODE)
               END=CPOS
C
               IF (CODE.EQ.0) THEN
                  CPOS=BPOS(II)-1
                  CODE=-1
                  CALL WOBJECT(BUFF,N,CPOS,OPOS(1,1),CODE)
                  START=CPOS
                  IF (CODE.EQ.0) THEN
                     CALL CEQUAL (BUFF1,100,BUFF,OPOS(1,1),OPOS(2,1))
                     CALL CEQUAL (BUFF2,100,BUFF,OPOS(1,2),OPOS(2,2))
C
                     LENB1=LENGTH(BUFF1,100,LENB1)
                     LENB2=LENGTH(BUFF2,100,LENB2)
                     CALL CHOP(BUFF1,LENB1)
                     CALL CHOP(BUFF2,LENB1)
                     LENB1=LENGTH(BUFF1,100,LENB1)
                     LENB2=LENGTH(BUFF2,100,LENB2)
C
                     IRC=0
                     LCHNG=.FALSE.
                     CALL SLAVEM(BUFF1,BUFF2,BUFF3,KK,CLEAN,LCHNG,IRC)
                     IF (LCHNG) CHANGED=.TRUE.
                     DONE=(IRC.EQ.0)
                     IRC=0
C
                     IF (LCHNG) THEN
                        CALL CHOP(BUFF3,100)
                        LENB3=LENGTH(BUFF3,100,LENB3)
                        DELL=END-START+1
                        CALL SUBSTR(BUFF,N,BUFF3,100,START,DELL)
C
C     UPDATE POSITION OF REMAINING OPERATORS
                        LENB=LENB3-DELL
                        JJ=II+1
                        DO WHILE(JJ.LE.MAXB)
C     REMOVE JOB IF IT WAS INSIDE OTHER JOB
                           IF (BPOS(JJ).LE.START .OR.
     &                          BPOS(JJ).GT.END) THEN
                              BPOS(JJ)=BPOS(JJ)+LENB
                           ELSE
                              BPOS(JJ)=BPOS(MAXB)
                              MAXB=MAXB-1
                              JJ=JJ-1
                           ENDIF
C     REMOVE JOB IF IT FALLS OUTSIDE BUFFER
                           IF (BPOS(JJ).GT.N) THEN
                              BPOS(JJ)=BPOS(MAXB)
                              MAXB=MAXB-1
                              JJ=JJ-1
                           ENDIF
                           JJ=JJ+1
                        ENDDO
                     ENDIF
                  ENDIF
               ENDIF
            ENDDO
            LAST=.NOT.CLEAN
C     ONLY RUN THROUGH '+-' ONCE (SO THAT '+2' DOES NOT TURN INTO '{+2}')
            IF (KK.EQ.4)LAST=.TRUE.
            CLEAN=.FALSE.
         ENDDO
      ENDDO
C
      CALL SUBSTR(STRING,N,BUFF,N,POS(1)+1,POS(2)-POS(1)-1)
      LENB=LENGTH(BUFF,N,LENB)
      POS(2)=POS(1)+LENB+1
C
      RETURN
      END
#__mcat: ftunit.F     **DO NOT DELETE
      FUNCTION FTUNIT(IRC)
C***********************************************************************
C                                                                      *
C WRITTEN/MODIFIED BY:                                                 *
C--------------------------------------------------------------------- *
C|    NAME      |   DATE   |                 REASON                  | *
C--------------------------------------------------------------------- *
C| L. BEHRENDT  | 04/03/91 | NEW.                                    | *
C|              |          |                                         | *
C--------------------------------------------------------------------- *
C***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 IRC
C
      CHARACTER*8 MYNAME
      INTEGER*4 FTUNIT,UNIT,UN
      LOGICAL*4 FOUND,T,F
C
      DATA F       /.FALSE./
      DATA T       /.TRUE./
C
      DATA MYNAME /'FTUNIT'/
C
C
C------- Find an unused unit number between 30 and 99.
C
      UNIT=0
      UN=100
      FOUND=T
      DO WHILE (FOUND.AND.UN.GE.30)
         UN=UN-1
         INQUIRE(UNIT=UN,OPENED=FOUND)
C     WRITE(*,*) MYNAME,UN,FOUND
      ENDDO
      IF (FOUND) THEN
         WRITE(*,*) MYNAME,': ----------- WARNING ------------'
         WRITE(*,*) MYNAME,': NO UNUSED UNITS FOUND (30 TO 99)'
         WRITE(*,*) MYNAME,': ----------- WARNING ------------'
         IRC=107
      ELSE
         FTUNIT=UN
      ENDIF
C
      RETURN
      END
#__mcat: getcom.F     **DO NOT DELETE
      SUBROUTINE GETCOM(MAXCOM,NRCOM,COM20,HLP20,CMLEN,IRC)
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 MAXCOM, NRCOM
      CHARACTER*20 COM20(MAXCOM),HLP20(MAXCOM)
      INTEGER*4 CMLEN(MAXCOM),IRC
C
      CHARACTER*8 MYNAME
      DATA MYNAME /'GETCOM'/
      INTEGER*4 INRCOM,II,LENGTH
      EXTERNAL LENGTH
      DATA INRCOM /12/
C
C     DEFINE COMMANDS
C
      NRCOM=INRCOM
      IF (MAXCOM.LT.INRCOM) THEN
         WRITE(*,*) MYNAME,'System error.'
         IRC=999
         RETURN
      END IF
C     
      COM20(1)='if'
      HLP20(1)='(<expr>)'
      COM20(2)='elseif'
      HLP20(2)='(<expr>)'
      COM20(3)='else'
      CALL RESET(HLP20(3),20)
      COM20(4)='endif'
      CALL RESET(HLP20(4),20)
      COM20(5)='!'
      HLP20(5)='<UNIX command>'
      COM20(6)='include'
      HLP20(6)='(<file>)'
      COM20(7)='stop'
      CALL RESET(HLP20(7),20)
      COM20(8)='exit'
      HLP20(8)='<exit code>'
      COM20(9)='echo'
      HLP20(9)='<text>'
      COM20(10)='set'
      HLP20(10)='<var>=<expr[$(var)]>'
      COM20(11)='import'
      HLP20(11)='<var1> <var2> ...'
      COM20(12)='?'
      CALL RESET(HLP20(12),20)
C
      DO II=1,NRCOM
         CALL CHOP(COM20(II),20)
         CALL CHOP(HLP20(II),20)
C     FIND LENGTH OF COMMAND
         CMLEN(II)=LENGTH(COM20(II),20,3)
      ENDDO
C
C     
      RETURN
      END
#__mcat: getind.F     **DO NOT DELETE
      SUBROUTINE GETIND(IKODE,TYPE,SCNAME,AUX,CID100,CDR100,CLK100,
     &     IRC)
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 IKODE           ! -1=FILE WILL BE CREATED, 0=FILE MUST EXIST
      CHARACTER*12 TYPE,SCNAME,AUX
      CHARACTER*100 CID100, CDR100, CLK100
      INTEGER*4 IRC
C
      INTEGER*4 NRHDR,LINE
      PARAMETER (NRHDR=100)
      CHARACTER*100 HDR100(NRHDR),DAT100,
     &     BUFF100,NUKEHEAD
      EXTERNAL NUKEHEAD
      INTEGER*4 INTOUT
      LOGICAL*4 ENDOFF
C
      LOGICAL*4 LFLDAT(3),ACTIVE,SUCC,BDEB,OK,FOUND,DONE
      INTEGER*4 UNITI,FTUNIT,LENGTH,LENI,LEND,LENT,LENN,LENA,LENH,LENB
      EXTERNAL FTUNIT,LENGTH
      INTEGER*4 MAXSAT,NRSAT,II,KODE
      PARAMETER (MAXSAT = 20)
      CHARACTER*100 SAT100(MAXSAT),SAT100B
      CHARACTER*12 SNAM12(MAXSAT),AUX12(MAXSAT),SNAM12B,AUX12B
      CHARACTER*8 MYNAME
C
      DATA MYNAME /'GETIND'/
      DATA SUCC /.TRUE./
      DATA BDEB /.FALSE./
      DATA ACTIVE /.FALSE./
C
      CALL CHOP (SCNAME,12)
      LENN=LENGTH(SCNAME,12,3)
      CALL CHOP (AUX,12)
      LENA=LENGTH(AUX,12,3)
C
      IF (LENN.EQ.0) THEN
         WRITE(*,*) MYNAME,'Invalid spacecraft name (length=0).'
         IRC=456
         RETURN
      END IF
C
      UNITI = FTUNIT(IRC)
      IF (IRC.NE.0) RETURN
      LENI = LENGTH(CID100,100,10)
      IF (IKODE.EQ.-1) THEN     ! CREATE FILE IF IT DOES NOT EXIST
         OPEN(UNIT=UNITI, FILE=CID100, STATUS='UNKNOWN',
     &        FORM='FORMATTED',IOSTAT=IRC)
      ELSE                      ! FILE MUST EXIST
         OPEN(UNIT=UNITI, FILE=CID100, STATUS='OLD',
     &        FORM='FORMATTED',IOSTAT=IRC)
      END IF
      IF (IRC.NE.0) THEN
         WRITE(*,*) MYNAME,'ERROR OPENING:',
     &        CID100(1:LENI)
         RETURN
      END IF
C
      LFLDAT(1)=.FALSE.
      LFLDAT(2)=.FALSE.
      LFLDAT(3)=.FALSE.
      NRSAT=0
C
      DO II=1,NRHDR
         HDR100(II) = ''
      ENDDO
C
      HDR100(1)='GETIND INDEX FILE V1.0 [0]'
      HDR100(2)='LIST OF SATELLITES AND INDEXED FILES [*] %'
      HDR100(3)='LIST OF SATELLITES, CATEGORIES AND'//
     &     ' INDEXED FILES [*] %'
C
      WRITE(*,*) MYNAME,'----------------------------------------'
      WRITE(*,*) MYNAME,'Reading index file:'//
     &     CID100(1:LENI)
C
C     READ DATA FROM INPUT FILE..............................
C
      KODE=-1
      CALL NUKEM(KODE,UNITI,HDR100,INTOUT,DAT100,ENDOFF,IRC)
      IF (IRC.NE.0.AND.IKODE.EQ.-1) THEN
         WRITE(*,*) MYNAME,'Attempting to create index file.'
         IRC=0
      ELSE IF (IRC.NE.0) THEN
         WRITE(*,*) MYNAME,'Error return from NUKEM.'
         RETURN
      ELSE
C     
         LINE=INTOUT
C     
         KODE=0
         DO WHILE (.NOT.ENDOFF)
C     
C     READ NEXT DATA LINE
C     
            CALL NUKEM(KODE,UNITI,HDR100,INTOUT,DAT100,ENDOFF,IRC)
            IF (IRC.NE.0) THEN
               WRITE(*,*) MYNAME,'Error return from NUKEM.'
               RETURN
            END IF
            LINE=INTOUT
C     
            IF (BDEB) WRITE(*,*) MYNAME,'Debug: Read header:',LINE
C     
C     CHECK WHAT LINE WE JUST READ
C     
            IF (LINE.EQ.1) THEN ! GETIND V1.0
               LFLDAT(1) =.TRUE.
            ELSEIF (LINE.EQ.2) THEN ! SATELLITE NAME
               IF (LFLDAT(3)) THEN
                  WRITE(*,*) MYNAME,'INVALID INDEX FILE SYNTAX:'//
     &                 CID100(1:LENI)
                  IRC=345
                  RETURN
               END IF
               NRSAT=NRSAT+1
               IF (NRSAT.GT.MAXSAT) THEN
                  WRITE(*,*) MYNAME,'TOO MANY SATELLITES'
                  IRC=88
                  RETURN
               END IF
C     
               buff100 = NUKEHEAD(DAT100,100)
               SNAM12(NRSAT)= buff100(1:12)
               SAT100(NRSAT)=DAT100
C     
               DO II=NRSAT,2,-1
                  IF (SNAM12(II).LT.SNAM12(II-1)) THEN
                     SNAM12B=SNAM12(II)
                     SAT100B=SAT100(II)
                     SNAM12(II)=SNAM12(II-1)
                     SAT100(II)=SAT100(II-1)
                     SNAM12(II-1)=SNAM12B
                     SAT100(II-1)=SAT100B
                  END IF
               END DO
C     
               LFLDAT(2) =.TRUE.
            ELSEIF (LINE.EQ.3) THEN ! SATELLITE NAME+AUX
               IF (LFLDAT(2)) THEN
                  WRITE(*,*) MYNAME,'INVALID INDEX FILE SYNTAX:'//
     &                 CID100(1:LENI)
                  IRC=345
                  RETURN
               END IF
               NRSAT=NRSAT+1
               IF (NRSAT.GT.MAXSAT) THEN
                  WRITE(*,*) MYNAME,'TOO MANY SATELLITES'
                  IRC=88
                  RETURN
               END IF
C     
               buff100 = NUKEHEAD(DAT100,100)
               SNAM12(NRSAT)= buff100(1:12)
               buff100 = NUKEHEAD(DAT100,100)
               AUX12(NRSAT)= buff100(1:12)
               SAT100(NRSAT)=DAT100
C     
               DO II=NRSAT,2,-1
                  IF (SNAM12(II).LT.SNAM12(II-1)) THEN
                     SNAM12B=SNAM12(II)
                     AUX12B=AUX12(II)
                     SAT100B=SAT100(II)
                     SNAM12(II)=SNAM12(II-1)
                     AUX12(II)=AUX12(II-1)
                     SAT100(II)=SAT100(II-1)
                     SNAM12(II-1)=SNAM12B
                     AUX12(II-1)=AUX12B
                     SAT100(II-1)=SAT100B
                  END IF
               END DO
C     
               LFLDAT(3) =.TRUE.
            ELSE IF (LINE.NE.0) THEN ! LINE.EQ.0 IMPLIES SOMETIMES EOF
               WRITE(*,*) MYNAME,
     &              'System error, line not implemented:',LINE
               IRC=999
               RETURN
            ENDIF
         ENDDO
C     
         KODE=1
         CALL NUKEM(KODE,UNITI,HDR100,INTOUT,DAT100,ENDOFF,IRC)
         IF (IRC.NE.0) THEN
            WRITE(*,*) MYNAME,'Error return from NUKEM.'
            RETURN
         END IF
C
      END IF
C     
C     MUST CHECK IF AUX IS EMPTY AND INDEX FILE EXPECTS NON-EMPTY
C     
      IF (LENA.EQ.0 .AND. LFLDAT(3)) THEN
         WRITE(*,*) MYNAME,'System error.'
         IRC=999
         RETURN
      END IF
C
      IF (LENA.NE.0 .AND. LFLDAT(2)) THEN
         WRITE(*,*) MYNAME,'System error.'
         IRC=998
         RETURN
      END IF
C
C     find location
C
      FOUND = .false.
      II=1
      DONE = (II.GT.NRSAT .OR. FOUND)
      DO WHILE (.NOT. DONE)
         IF (LENA.EQ.0) THEN
            IF (SNAM12(II).EQ.SCNAME) THEN
               CLK100 = SAT100(II)
               FOUND = .TRUE.
            ELSE
               II = II+1
            END IF
         ELSE
            IF (SNAM12(II).EQ.SCNAME .AND. AUX12(II).EQ.AUX) THEN
               CLK100 = SAT100(II)
               FOUND = .TRUE.
            ELSE
               II = II+1
            END IF
         END IF
         DONE = (II.GT.NRSAT .OR. FOUND)
      END DO
C
      IF (.NOT.FOUND .AND. IKODE.EQ.-1) THEN ! add sat if it does not exist
         FOUND = .TRUE.
         NRSAT=NRSAT+1
         IF (NRSAT.GT.MAXSAT) THEN
            WRITE(*,*) MYNAME,'TOO MANY SATELLITES'
            IRC=91
            RETURN
         END IF
         CALL CHOP (CDR100,100)
         CALL CHOP (TYPE,12)
         LEND=LENGTH(CDR100,100,10)
         LENT=LENGTH(TYPE,12,10)
         SNAM12(NRSAT)= SCNAME
         AUX12(NRSAT)= AUX
         IF (CDR100(LEND:LEND).EQ.'/') THEN
            IF (LENA.EQ.0) THEN
               SAT100(NRSAT)=CDR100(1:LEND)//
     &              SCNAME(1:LENN)//TYPE(1:LENT)
            ELSE
               SAT100(NRSAT)=CDR100(1:LEND)//
     &              SCNAME(1:LENN)//AUX(1:LENA)//TYPE(1:LENT)
            END IF
         ELSE
            IF (LENA.EQ.0) THEN
               SAT100(NRSAT)=CDR100(1:LEND)//'/'//
     &              SCNAME(1:LENN)//TYPE(1:LENT)
            ELSE
               SAT100(NRSAT)=CDR100(1:LEND)//'/'//
     &              SCNAME(1:LENN)//AUX(1:LENA)//TYPE(1:LENT)
            END IF
         END IF
         CALL CHOP(SAT100(NRSAT),100)
         CLK100 = SAT100(NRSAT)
C
         DO II=NRSAT,2,-1
            IF (SNAM12(II).LT.SNAM12(II-1)) THEN
               IF (LENA.EQ.0) THEN
                  SNAM12B=SNAM12(II)
                  SAT100B=SAT100(II)
                  SNAM12(II)=SNAM12(II-1)
                  SAT100(II)=SAT100(II-1)
                  SNAM12(II-1)=SNAM12B
                  SAT100(II-1)=SAT100B
               ELSE
                  SNAM12B=SNAM12(II)
                  AUX12B=AUX12(II)
                  SAT100B=SAT100(II)
                  SNAM12(II)=SNAM12(II-1)
                  AUX12(II)=AUX12(II-1)
                  SAT100(II)=SAT100(II-1)
                  SNAM12(II-1)=SNAM12B
                  AUX12(II-1)=AUX12B
                  SAT100(II-1)=SAT100B
               END IF
            END IF
         END DO
      ELSE IF (.NOT. FOUND) THEN
         WRITE(*,*) MYNAME,'No data file found for satellite:'//
     &        SCNAME(1:LENN), '('//AUX(1:LENA)//')'
         IRC=92
         RETURN
      END IF
C
      CLOSE(UNITI)
C
C     WRITE TO FILE
C
      IF (IKODE.EQ.-1) THEN
         OPEN(UNIT=UNITI, FILE=CID100, STATUS='UNKNOWN',
     &        FORM='FORMATTED',IOSTAT=IRC)
         IF (IRC.NE.0) THEN
            WRITE(*,*) MYNAME,'ERROR OPENING:',
     &           CID100(1:LENI)
            RETURN
         END IF
C
         buff100='#!NUKE'
         call chop(buff100,100)
         lenB=length(buff100,100,3)
         WRITE(UNITI,*) buff100(1:lenb)
C
         buff100='#'
         call chop(buff100,100)
         lenB=length(buff100,100,3)
         WRITE(UNITI,*) buff100(1:lenb)
C
         buff100=HDR100(1)
         call chop(buff100,100)
         lenB=length(buff100,100,3)
         WRITE(UNITI,*) buff100(1:lenb)
C
         buff100='#'
         call chop(buff100,100)
         lenB=length(buff100,100,3)
         WRITE(UNITI,*) buff100(1:lenb)
C
         IF (NRSAT.NE.0) THEN
C
            IF (LENA.EQ.0) THEN
               buff100=HDR100(2)
            ELSE
               buff100=HDR100(3)
            END IF
            call chop(buff100,100)
            lenB=length(buff100,100,3)
            WRITE(UNITI,*) buff100(1:lenb)
            DO II=1,NRSAT
               lenn=length(SNAM12(II),12,3)
               lena=length(AUX12(II),12,3)
               lend=length(SAT100(II),100,10)
               IF (LENA.EQ.0) THEN
                  buff100=SNAM12(II)(1:LENN)//' '//
     &                 SAT100(II)(1:MIN(LEND,100-1-LENN))
               ELSE
                  buff100=SNAM12(II)(1:LENN)//' '//
     &                 AUX12(II)(1:LENA)//' '//
     &                 SAT100(II)(1:MIN(LEND,100-2-LENN-LENA))
               END IF
               call chop(buff100,100)
               lenB=length(buff100,100,3)
               WRITE(UNITI,*) buff100(1:lenb)
            END DO
         ELSE
            buff100='# NO SATELLITE DEFINED.'
            call chop(buff100,100)
            lenB=length(buff100,100,3)
            WRITE(UNITI,*) buff100(1:lenb)
         END IF
C
         buff100='#'
         call chop(buff100,100)
         lenB=length(buff100,100,3)
         WRITE(UNITI,*) buff100(1:lenb)
C
         CLOSE(UNITI)
C
         IF (.NOT.FOUND) THEN
            WRITE(*,*) MYNAME,'Undefined satellite:',SCNAME
            IRC=93
            RETURN
         END IF
      END IF
C
      WRITE(*,*) MYNAME,'----------------------------------------'
C
      RETURN
      END
#__mcat: getline.F     **DO NOT DELETE
      subroutine GETLINE(MAXUNIT,UNITA,FILES,LUNIT,CUNIT,
     &     CNT,MAXHDR,CODHDR,LINE,
     &     BUFF1000,LENB,ENDOFF,IRC)
C
      implicit none
      save
C
      INTEGER*4 MAXUNIT
      INTEGER*4 UNITA(MAXUNIT),CUNIT,LUNIT(MAXUNIT)
      CHARACTER*100 FILES(MAXUNIT)
      INTEGER*4 CNT,MAXHDR,CODHDR(MAXHDR),LINE
      CHARACTER*1000 BUFF1000
      integer*4 lenb
      logical*4 endoff
      integer*4 irc
C
      INTEGER*4 FTUNIT, LENGTH, LEND,LENF,IUNIT
      EXTERNAL FTUNIT, LENGTH
      LOGICAL*4 BDONE
      CHARACTER*100 BUFF100
      CHARACTER*8 MYNAME
      DATA MYNAME /'GETLINE'/
C
      DATA IUNIT/-1/
C
      IF (IUNIT.NE.-1 .AND. IUNIT.NE.CUNIT) THEN
C
         IF (CUNIT.GT.IUNIT) THEN
C     
C     OPEN THE NEW FILE
C     
            IF (CUNIT.GT.MAXUNIT) THEN
               WRITE(*,*) MYNAME,'Too deep file nesting.'
               IRC=275
               RETURN
            END IF
C     
            LUNIT(CUNIT)=0
            UNITA(CUNIT)=FTUNIT(IRC)
            IF (IRC.NE.0) RETURN
C     
            LENF=LENGTH(FILES(CUNIT),100,10)
            OPEN(UNIT=UNITA(CUNIT),FILE=FILES(CUNIT)(1:LENF),
     &           ACCESS='SEQUENTIAL',FORM='FORMATTED',
     &           STATUS='OLD',IOSTAT=IRC)
C     
            IF (IRC.NE.0) THEN
               WRITE(*,*) MYNAME,'Unable to open file:'//
     &              FILES(CUNIT)(1:LENF)
               RETURN
            END IF
         ELSE
C
C     CLOSE THE OLD FILE
C            
            CLOSE(UNITA(IUNIT),IOSTAT=IRC)
         END IF
      END IF
C
      IUNIT=CUNIT
C
C     READ NEXT LINE
C
      BUFF1000=''
      LENB=0
      BDONE=.FALSE.
      DO WHILE (.NOT.BDONE)
         READ(UNITA(CUNIT),'(A100)',END=99,IOSTAT=IRC) BUFF100
         LUNIT(CUNIT)=LUNIT(CUNIT)+1
         IF (IRC.NE.0) THEN
            LENF=LENGTH(FILES(CUNIT),100,10)
            WRITE(*,*) 
     &           '"'//FILES(CUNIT)(1:LENF)//'", line ',
     &           LUNIT(CUNIT),': Error: Unable to read line.'
            RETURN
         END IF
C
         CALL CHOP (BUFF100,100)
         LEND=LENGTH(BUFF100,100,10)
C
C     IGNORE COMMENTS
C
         IF (LEND.NE.0 .AND. BUFF100(1:1).NE.'#') THEN
            BUFF1000=BUFF1000(1:LENB)//BUFF100(1:LEND)
            LENB=LENB+LEND
            IF (BUFF1000(LENB:LENB).EQ.'~') THEN
               BUFF1000(LENB:LENB)=' '
               LENB=LENB-1
               BDONE=.FALSE.
            ELSE
               BDONE=.TRUE.
            END IF
         END IF
C
         GOTO 100
 99      CONTINUE
         IRC=0                  ! NO ERROR, JUST EOF
         IF (CUNIT.GT.1) THEN
            CUNIT=CUNIT-1
         ELSE
C
C     END OF FILE
C
            IF (LINE.NE.-1) THEN
               IF (CNT.LT.CODHDR(LINE)
     &              .AND. CODHDR(LINE).NE.-1) THEN
                  WRITE(*,*) MYNAME,'EOF interrupts data body.'
                  IRC=174
                  RETURN
               END IF
            END IF
            ENDOFF=.TRUE.
            BDONE=.TRUE.
         END IF
C
 100     CONTINUE
      END DO
      RETURN
C
      END

      
#__mcat: isint.F     **DO NOT DELETE
      LOGICAL*4 FUNCTION ISINT(STRING,OUT)
C     ***********************************************************************
C     +                                                                     *
C     CHECKS IF STRING IS AN INTEGER                                        *
C     +                                                                     *
CI    STRING (C*100) = STRING TO BE EXAMINED                                  *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      CHARACTER*100 STRING
      INTEGER*4 OUT
C
      INTEGER*4 LENS,II,LENGTH,NRSG
      LOGICAL*4 BUFF, DIGIT
      EXTERNAL LENGTH,DIGIT
      DATA LENS/1/
C
      CALL CHOP(STRING,100)
      LENS=LENGTH(STRING,100,LENS)
C
      BUFF=(LENS.GT.0)
      NRSG=0
      II=0
      DO WHILE (II.LT.LENS.AND.BUFF)
         II=II+1
         IF (BUFF) THEN
            IF (STRING(II:II).EQ.'-'.OR.STRING(II:II).EQ.'+') THEN
               NRSG=NRSG+1
               BUFF=(II.EQ.1.AND.NRSG.LE.1)
            ELSE
               BUFF=(DIGIT(STRING(II:II)))
            ENDIF
         ENDIF
      ENDDO
C
      IF (BUFF) THEN
         READ(STRING(1:LENS),*,ERR=99,END=99) OUT
         ISINT=BUFF
         RETURN
 99      BUFF=.FALSE.
         ISINT=BUFF
         RETURN
      ENDIF
C
      ISINT=BUFF
      RETURN
      END
#__mcat: islog.F     **DO NOT DELETE
      LOGICAL*4 FUNCTION ISLOG(STRING,OUT)
C     ***********************************************************************
C     +                                                                     *
C     CHECKS IF STRING IS LOGICAL                                           *
C     +                                                                     *
CI    STRING (C*100) = STRING TO BE EXAMINED                                  *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      CHARACTER*100 STRING
      LOGICAL*4 OUT
C
      CHARACTER*7 TEXT
      INTEGER*4 LENS,LENGTH
      LOGICAL*4 BUFF
      EXTERNAL LENGTH
C
      CALL CHOP(STRING,100)
      LENS=MIN(MAX(LENS,1),100)
      LENS=LENGTH(STRING,100,LENS)
C
      BUFF=.FALSE.
      IF (LENS.LE.7) THEN
C
         CALL RESET(TEXT,7)
         TEXT(1:LENS)=STRING(1:LENS)
C
         IF (TEXT(1:LENS).EQ.'T') THEN
            OUT=.TRUE.
            BUFF=.TRUE.
         ELSEIF(TEXT(1:LENS).EQ.'TRUE') THEN
            OUT=.TRUE.
            BUFF=.TRUE.
         ELSEIF(TEXT(1:LENS).EQ.'.TRUE.') THEN
            OUT=.TRUE.
            BUFF=.TRUE.
         ELSEIF(TEXT(1:LENS).EQ.'F') THEN
            OUT=.FALSE.
            BUFF=.TRUE.
         ELSEIF(TEXT(1:LENS).EQ.'FALSE') THEN
            OUT=.FALSE.
            BUFF=.TRUE.
         ELSEIF(TEXT(1:LENS).EQ.'.FALSE.') THEN
            OUT=.FALSE.
            BUFF=.TRUE.
         ENDIF
      ENDIF
C
      ISLOG=BUFF
C
      RETURN
      END
#__mcat: isreal.F     **DO NOT DELETE
      LOGICAL*4 FUNCTION ISREAL(STRING,OUT)
C     ***********************************************************************
C     +                                                                     *
C     CHECKS IS STRING IS A REAL NUMBER                                     *
C     +                                                                     *
CI    STRING (C*100) = STRING TO BE EXAMINED                                  *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      CHARACTER*100 STRING
      REAL*8 OUT
C
      INTEGER*4 LENS,II,LENGTH,
     &     POSSG,POSNR,POSDE,POSDD,
     &     NRSGN,NRNRR,NRDES,NRDDE
      LOGICAL*4 BUFF, DIGIT
      EXTERNAL DIGIT,LENGTH
      DATA LENS /1/
C
      CALL CHOP(STRING,100)
      LENS=LENGTH(STRING,100,1)
C
C
      POSSG=-1
      POSNR=-1
      POSDE=-1
      POSDD=-1
C
      NRSGN=0
      NRNRR=0
      NRDES=0
      NRDDE=0
C
      BUFF=(LENS.GT.0)
      II=0
      DO WHILE (II.LT.LENS.AND.BUFF)
         II=II+1
         IF (BUFF) THEN
            IF (STRING(II:II).EQ.'.') THEN
               NRDES=NRDES+1
               POSDE=II
               BUFF=(NRDES.LE.1.AND.NRDDE.LT.1)
            ELSEIF (STRING(II:II).EQ.'D' .OR. STRING(II:II).EQ.'E') THEN
               NRDDE=NRDDE+1
               POSDD=II
               BUFF=(NRDDE.LE.1 .AND. II.LT.LENS)
            ELSEIF (STRING(II:II).EQ.'-'.OR.STRING(II:II).EQ.'+') THEN
               NRSGN=NRSGN+1
               POSSG=II
               BUFF=((NRSGN.LE.1.AND.II.EQ.1) .OR.
     &              (NRSGN.LE.2.AND.NRDDE.EQ.1
     &              .AND.POSDD.EQ.(POSSG-1)
     &              .AND.II.LT.LENS))
            ELSE
               BUFF=(DIGIT(STRING(II:II)))
               IF (BUFF) POSNR=II
            ENDIF
         ENDIF
      ENDDO
C
      IF (BUFF) BUFF=NRDES.GT.0
C
      IF (BUFF) THEN
         READ(STRING(1:LENS),*,ERR=99,END=99) OUT
         ISREAL=BUFF
         RETURN
 99      BUFF=.FALSE.
         ISREAL=BUFF
         RETURN
      ENDIF
C
      ISREAL=BUFF
      RETURN
      END
#__mcat: item.F     **DO NOT DELETE
      SUBROUTINE ITEM(STRING,N,DEL,LEV,POS,IRC)
C     ***********************************************************************
C     +                                                                     *
C     RETURNS THE POSITION OF THE SUBSTRING (AT LEVEL LEV), WITH THE        *
C     DELIMITERS DEL(2). IF THE SPECIFIED LEVEL IS NOT FOUND, THE ROUTINE   *
C     RETURNS THE LOWEST LEVEL IN THE STRING, E.G. STRING="1+((2+(3)))"     *
C     CALLED WITH DEL(1)='(',DEL(2)=')' AND LEV=-1 GIVES POS(1)=7,POS(2)=9  *
C     +                                                                     *
CI    STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    N (I*4) = LENGTH OF STRING                                            *
CI    DEL(2) (C*1) = THE START AND END DELIMITER TO SEARCH FOR              *
CI    LEV = LEVEL TO SEARCH FOR, E.G. '(a)' AND '((a))' ARE RESP. LEV=1,2   *
CIO   POS(2) (I*4) = POSITION TO SEARCH WITHIN/LOCATION OF SUBSTRING        *
CO    IRC (I*4) = ERROR RETURN CODE (IRC=0 ALL OK)                          *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
C     STRING WHOLE STRING IN WHICH TO SEARCH
C     N= LENGTH OF STRING
C     DEL=DELIMITERS IN WHICH TO SEARCH FOR
C     POS=LIMIT OF STRING TO SEARCH FOR, ALSO LOC OF DEL
C
C     IDENTIFIES AN ITEM STARTING WITH DEL(1) AND ENDING WITH DEL(2)
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N,LEV
      CHARACTER*1 DEL(2)
      CHARACTER*(*) STRING
      INTEGER*4 II,IRC,POS(2),MPOS(2),LEVEL,MAXLEV,START,STOP
      LOGICAL*4 FOUND(2),MFOUND(2)
C
C     FIND START
C
      START=POS(1)
      STOP=POS(2)
C
      LEVEL=0
      MAXLEV=-1
      MPOS(1)=START
      MPOS(2)=STOP
      POS(1)=0
      POS(2)=0
      FOUND(1)=.FALSE.
      FOUND(2)=.FALSE.
C
      II=START
      DO WHILE (II.LE.STOP)
         IF (STRING(II:II).EQ.DEL(1)) THEN
            IF (.NOT. FOUND(1) .AND. LEVEL.EQ.LEV) THEN
               POS(1)=II
               FOUND(1)=.TRUE.
            ENDIF
            LEVEL=LEVEL+1
            IF (LEVEL.GT.MAXLEV) THEN
               MAXLEV=LEVEL
               MPOS(1)=II
               MFOUND(1)=.TRUE.
               MFOUND(2)=.FALSE.
            ENDIF
         ELSEIF(STRING(II:II).EQ.DEL(2)) THEN
            IF (.NOT.MFOUND(2).AND.LEVEL.EQ.MAXLEV) THEN
               MPOS(2)=II
               MFOUND(2)=.TRUE.
            ENDIF
            LEVEL=LEVEL-1
            IF (.NOT. FOUND(2) .AND. LEVEL.EQ.LEV) THEN
               POS(2)=II
               FOUND(2)=.TRUE.
            ENDIF
         ENDIF
         IF (LEVEL.LT.0) THEN
            IRC=98
         ENDIF
         II=II+1
      ENDDO
C
      IF (LEVEL.NE.0) IRC=99
C
      IF (.NOT. FOUND(1) .OR. .NOT. FOUND(2)) THEN
         LEV=MAXLEV
         POS(1)=MPOS(1)
         POS(2)=MPOS(2)
      ENDIF
C
      RETURN
      END
#__mcat: jd2000.F     **DO NOT DELETE
      SUBROUTINE JD2000(DAY,YY,MM,DD,HH,MI,SEC)
CP GIVES THE NEW MOD. JULIAN DAY (MJD=0.0 ON 2000/JAN/1 AT 0:00:00)
CP FOR INPUT CALENDAR DATES BETWEEN 1950/JAN/1 AND 2099/DEC/31.
C
C   MJD(2000) = MJD(1950) - 18262.0 IS = 0 ON 2000/01/01 AT 00:00:00.
C
CI  (INT*4) YY = YEAR WITH 2 OR 4 DIGITS; 2 DIGITS => 1950 TO 2049
CI  (INT*4) MM = MONTH
CI  (INT*4) DD = DAY
CI  (INT*4) HH = HOUR
CI  (INT*4) MI = MINUTE
CI  (REAL*8) SEC = SECOND.
CO  (REAL*8) DAY = MOD. JUL. DAY, REFERRED TO 2000.
C
      IMPLICIT NONE
      SAVE
C
      CHARACTER*40 SCCS_INFO
      DATA SCCS_INFO
     & /'@(#)jd2000.f \n'/
C
      REAL*8 DAY,SEC
      INTEGER*4 YY, MM,DD,HH,MI,JJ,L
      JJ = (14 - MM)/12
      L = YY - JJ - 1900*(YY/1900) + 100*(2000/(YY+1951))
      DAY = DD-36496+(1461*L)/4+(367*(MM-2+JJ*12))/12
      DAY = DAY + (DFLOAT((HH*60 + MI)*60) + SEC)/864.D2
      RETURN
      END
#__mcat: length.F     **DO NOT DELETE
      INTEGER*4 FUNCTION LENGTH(STRING,N,GUESS)
C     ***********************************************************************
C     +                                                                     *
C     GIVES THE LENGTH OF THE STRING                                        *
C     +                                                                     *
CI    STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    N (I*4) = LENGTH OF STRING                                            *
CI    GUESS (I*4) = FIRST GUESS FOR LENGTH                                  *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N,LL,LENS,GUESS
      CHARACTER*(*) STRING
      CHARACTER*1 C1
      LOGICAL*4 BL,FORW,DONE
C
      LOGICAL*4 FIRST
      DATA FIRST /.TRUE./
C
      IF (FIRST) THEN
         C1=CHAR(0)
         FIRST=.FALSE.
      ENDIF
C
      DONE=.FALSE.
      LENS=0
C
      LL=GUESS
      IF (LL.LT.1) LL=1
      IF (LL.GT.N) LL=N
C
      BL=(STRING(LL:LL).EQ.C1)
      IF (.NOT.BL)LENS=LL
      FORW=(.NOT.BL)
C
      IF (FORW) THEN
         LL=LL+1
      ELSE
         LL=LL-1
      ENDIF
C
      DO WHILE (LL.GE.0.AND.LL.LE.N.AND..NOT.DONE)
C
         BL=(STRING(LL:LL).EQ.C1)
         IF (.NOT.BL)LENS=LL
C
         DONE=((BL.AND.FORW).OR.(.NOT.BL.AND..NOT.FORW))
C
         IF (FORW) THEN
            LL=LL+1
         ELSE
            LL=LL-1
         ENDIF
C
      ENDDO
C
      LENGTH=LENS
C
      RETURN
      END
#__mcat: nuke.F     **DO NOT DELETE
      SUBROUTINE NUKE(KODE,UNITI,HDR100,INTOUT,DAT100,NRDAT,IRC)
C     ***********************************************************************
C     +                                                                     *
C     INTERFACE SUBROUTINE TO FORTRAN-PROGRAM INPUT FILES                   *
C     +                                                                     *
CI    KODE (I*4) = INITIALISATION CODE, KODE=-1 REINITIALISES               *
CI    UNITI (I*4) = UNIT NUMBER FOR INPUT FILE (5=STANDARD INPUT)           *
CI    HDR100(100) (C*100) = HEADERS TO SEARCH FOR IN INPUT FILE             *
C     +   HEADER MUST BE ON FORM 'THIS IS THE HEADER [N]P', WHERE N         *
C     +   IS THE NUMBER OF LINES INCLUDED IN DATA LINE (CONCATENATED).      *
C     +   IF 'N'='*' THEN ONE DATA LINE IS RETURNED PER LINE IN THE FILE    *
C     +   (NOTE: THE HEADER IS IN THIS CASE ONLY NEEDED ONCE).              *
C     +   A 'P' AT THE END IMPLIES THAT THE DATA SHOULD BE PREPROCESSED.    *
CO    INTOUT(NRDAT) (I*4) = HEADER ID (LOC IN ARRAY) FOR DATA FOUND IN FILE *
CO    DAT100 (C*100) = DATA BODY                                     *
C     +      II=INTOUT(JJ) => HEADER HDR100(II) HAD DATABODY DAT100(JJ)     *
CI    NRDAT (I*4) = NUMBER OF DATA LINES (THE PROGRAM WILL PICK UP FROM     *
C     +    ITS LAST POSITION IN FILE IF IT IS CALLED SEVERAL TIMES).        *
C     +    IF THE ROUTINE REACHES END OF FILE (OR 'stop') BEFORE IT HAS     *
C     +    FILLED NRDAT LINES, THE LINE AFTER LAST LINE WILL HAVE INOUT=0   *
CIO   IRC (I*4) = ERROR RETURN CODE (IRC=0, ALL OK)                         *
C     +     A CALL WITH (IRC.NE.0) WILL INITIALISE THE ROUTINE              *
C     +                                                                     *
C     NOTE :                                                                *
C     +   o THE LINE '?' IN INPUT FILE WILL LIST ALL HEADERS AND COMMANDS   *
C     +   o IT IS POSSIBLE TO BYPASS THE MATHEMATICAL PREPROCESSOR          *
C     +     (IF IT FAILS TO WORK). IF THE MATHEMATICAL EXPRESSION IS        *
C     +     CONTAINED IN {}, IT WILL NOT BE EVALUATED ({} ARE DELETED), AN  *
C     +     ALTERNATIVE IS [] ([] ARE CONVERTED INTO ()).                   *
C     +                                                                     *
C     EXAMPLE OF CALL SEQUENCE :                                            *
C     +                                                                     *
C     INTEGER*4 NRDAT,IRC,UNITI                                             *
C     PARAMETER (NRDAT=1)                                                   *
C     CHARACTER*100 HDR100(100),DAT100                               *
C     INTEGER*4 INTOUT(NRDAT)                                               *
C     UNITI=5                                                               *
C     HDR100(1)='THIS IS A HEADER : [*]P'                                   *
C     CALL NUKE(KODE,UNITI,HDR100,INTOUT,DAT100,NRDAT,IRC)                       *
C     +                                                                     *
C     EXAMPLE OF INPUT FILE (THE 'C     ' AND '*' SHOULD BE IGNORED)        *
C     +                                                                     *
C     # first line (comment)                                                *
C     # test input file (yet another comment)                               *
C       THIS IS A HEADER :                                                  *
C        data-string data1                                                  *
C        1+2 +1.0D-4^-2 +23/1.01D2 +(1*(-1*(1*(-1*(1*(-2)))))) data2        *
C     # (...and another comment) The next line gives (some) help            *
C        ?                                                                  *
C     # last line (last comment)                                            *
C     +                                                                     *
C     THE DATA IN THE ABOVE FILE IS INTERPRETED AS :                        *
C     data-string data1                                                     *
C     3 +100000000. +0.22772277227723 +(-2) data2                           *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 NRHDR
      PARAMETER (NRHDR=100)
C
C     INTERFACE VARIABLES
C
      INTEGER*4 KODE,UNITI,NRDAT
      CHARACTER*100 HDR100(NRHDR),DAT100(NRDAT)
      INTEGER*4 INTOUT(NRDAT),IRC
C
C     INTERNAL VARIABLES
C
      INTEGER*4 NROPT
      PARAMETER (NROPT=5)
      LOGICAL*4 PPDAT(NROPT,NRHDR)
      INTEGER*4 NRLEN(NRHDR),CODHDR(NRHDR),MAXHDR,CURHDR
      LOGICAL*4 ACTHDR(NRHDR)
C
      INTEGER*4 MAXCOM,COMMAND,IRC1,
     &     LENGTH,LENS,LENB,LEND,LENF,LENH,LEN2,LEN3,MEAN
      PARAMETER (MAXCOM=12)
      CHARACTER*20 COM20(MAXCOM),HLP20(MAXCOM)
      CHARACTER*100 STRING,DUMP,JUNK,NUKEHEAD
      CHARACTER*1000 BUFF,BUFF2,BUFF3,PATHF
      CHARACTER*1 DEL(2),C1
      EXTERNAL FTUNIT,LENGTH
      INTEGER*4 CMLEN(MAXCOM),system,putenv,FTUNIT,LEV
      EXTERNAL system,putenv
C
      INTEGER*4    II,JJ,KK,LINE,CNT,
     &     CPOS,POS(2),IFLVL
C
      CHARACTER*3 PRE
      CHARACTER*1 OPT,OPTL(NROPT)
      DATA OPTL /'V','F','M','L','R'/
C
      LOGICAL*4 DONE,BDONE,SUCC,PROCESSED,ERROR,RDATA,
     &     SPLIT,FIRST,FOUND,ROCK,
     &     IFACT(10),IFDON(10),IFVAL,COMP,GO,DONCOM
      DATA FIRST /.TRUE./
C
C     AUXILIARY VARIABLES
C
      INTEGER*4 MAXVAR
      PARAMETER (MAXVAR=50)
      INTEGER*4 VARLEN(MAXVAR),NRVAR,CVAR
      CHARACTER*100 NAMVAR(MAXVAR),VALVAR(MAXVAR)
C
C     UNIT CONTROLLERS
C
      INTEGER*4 MAXUNIT
      PARAMETER (MAXUNIT=10)
      INTEGER*4 UNITA(MAXUNIT),CUNIT,LUNIT(MAXUNIT)
      CHARACTER*100 FILES(MAXUNIT)
C
C     EQUAL SIGN IDENTIFIERS
C
      INTEGER*4 MAXEQN
      PARAMETER (MAXEQN=100)
      INTEGER*4 POSEQN(MAXEQN),CEQN
C
      CHARACTER*8 MYNAME
      DATA MYNAME /'NUKE'/
      LOGICAL*4 BDEB,ACTIVE
      DATA ACTIVE /.FALSE./
C
C     Debug System.
C
      IF (.NOT.ACTIVE) CALL DEBUG(MYNAME,BDEB,ACTIVE)
C
      IF (BDEB) WRITE(*,*) MYNAME,'Debug: Routine starts.',IRC
C
C     INITIALIZE (ALWAYS)
C
      ERROR=.FALSE.
      SUCC=.TRUE.
      CURHDR=0
      INTOUT(1)=0
C
C     CHECK IF WE SHOULD RE-INITIALISE
C
      IF (KODE.NE.0) THEN
         FIRST=.TRUE.
         KODE=0
      ENDIF
C
      IF (FIRST) THEN
C
         C1=CHAR(0)
C
C     DEFINE COMMANDS
C
         COM20(1)='if'
         HLP20(1)='(<expr>)'
         COM20(2)='elseif'
         HLP20(2)='(<expr>)'
         COM20(3)='else'
         CALL RESET(HLP20(3),20)
         COM20(4)='endif'
         CALL RESET(HLP20(4),20)
         COM20(5)='!'
         HLP20(5)='<UNIX command>'
         COM20(6)='include'
         HLP20(6)='(<file>)'
         COM20(7)='stop'
         CALL RESET(HLP20(7),20)
         COM20(8)='exit'
         HLP20(8)='<exit code>'
         COM20(9)='echo'
         HLP20(9)='<text>'
         COM20(10)='set'
         HLP20(10)='<var>=<expr[$(var)]>'
         COM20(11)='import'
         HLP20(11)='<var1> <var2> ...'
         COM20(12)='export'
         HLP20(12)='<var1> <var2> ...'
C
C     ANALYZE HEADERS
C
         LENH=1
         MEAN=0
         II=1
         DO WHILE(II.LE.NRHDR)
            CALL CHOP(HDR100(II),100)
            LENH=LENGTH(HDR100(II),100,LENH)
            IF (LENH.EQ.0) THEN
C     THE HEADER IS BLANK
               ACTHDR(II)=.FALSE.
            ELSE
               ACTHDR(II)=.TRUE.
               MAXHDR=II
C
C     FIND LENGTH OF HEADER, AND LOCATION OF []...
C
               DEL(1)='['
               DEL(2)=']'
               LEV=0
               POS(1)=1
               POS(2)=100
               IRC1=0
               CALL ITEM(HDR100(II),100,DEL,LEV,POS,IRC1)
               IF (IRC1.NE.0 .OR. LEV .EQ. -1) THEN
                  WRITE(*,*) MYNAME,
     &                 'Error: missing [] in header, ',II,'.'
                  IF(IRC.EQ.0)IRC=100
                  RETURN
               ENDIF
               NRLEN(II)=POS(1)-1
               MEAN=MEAN+NRLEN(II)
               IF (NRLEN(II).GT.0) THEN
                  IF (HDR100(II)(NRLEN(II):NRLEN(II)).EQ.' ')
     &                 NRLEN(II)=NRLEN(II)-1
               ELSE
                  WRITE(*,*) MYNAME,'Error: header too short, ',II,'.'
                  IF(IRC.EQ.0)IRC=101
               ENDIF
C
C     CHECK FOR PRE-PROCESSOR COMMANDS
C
               DO KK=1,NROPT
                  PPDAT(KK,II)=.FALSE.
               ENDDO
               DO JJ=POS(2)+1,LENH
                  OPT=HDR100(II)(JJ:JJ)
                  FOUND=.FALSE.
                  DO KK=1,NROPT
                     IF (OPT.EQ.OPTL(KK)) THEN
                        PPDAT(KK,II)=.TRUE.
                        FOUND=.TRUE.
                     ENDIF
                  ENDDO
                  IF (.NOT.FOUND) THEN
                     WRITE(*,*) MYNAME,
     &                    'Error: unknown header option, ',
     &                    OPT,'.'
                  ENDIF
               ENDDO
C
C     GET INFO CONCERNING THE NUMBER OF LINES IN THE DATA BODY
C
               READ(HDR100(II)(POS(1)+1:POS(2)-1),*,ERR=99) CODHDR(II)
 100           GOTO 101
 99            IF (HDR100(II)(POS(1)+1:POS(1)+1).EQ.'*'
     &              .OR.HDR100(II)(POS(1)+2:POS(1)+2).EQ.'*') THEN
                  CODHDR(II)=-1
               ELSE
                  CODHDR(II)=0
               ENDIF
 101           CONTINUE
C
            ENDIF
            II=II+1
         ENDDO
C
C     MEAN HEADER LENGTH
C
         IF (NRHDR.GT.0) MEAN=INT(MEAN/NRHDR)
C
C     ANALYZE COMMANDS
C
         DO II=1,MAXCOM
            CALL CHOP(COM20(II),20)
            CALL CHOP(HLP20(II),20)
C     FIND LENGTH OF COMMAND
            CMLEN(II)=LENGTH(COM20(II),20,3)
         ENDDO
C
C     INITIALIZE
C
         CNT=0
         SPLIT=.FALSE.
C
C
C     READ DATA FROM INPUT FILE..............................
C
C     INITIALIZE
C
         IFLVL=0
         CUNIT=1
         UNITA(CUNIT)=UNITI
         LUNIT(CUNIT)=0
         FILES(CUNIT)='input file'
         RDATA=.FALSE.
C
C     READ UNTIL WE FIND A '#! NUKE' STATEMENT IN INPUT FILE (=line 1)
C
         LUNIT(CUNIT)=1
         ROCK=.TRUE.
         DO WHILE(ROCK)
            READ(UNITA(CUNIT),'(A100)',ERR=50,END=50) STRING
            BUFF(1:100)=STRING
            CALL CHOP(BUFF,100)
            IF (BUFF(1:7).EQ.'#! NUKE' .OR.
     &           BUFF(1:6).EQ.'#!NUKE') THEN
               ROCK=.FALSE.
            ENDIF
            GOTO 55
 50         CUNIT=CUNIT-1
            WRITE(*,*) MYNAME,'Error: input file corrupted.'
            IRC=102
            ROCK=.FALSE.
 55         CONTINUE
         ENDDO
C
         FIRST=(IRC.NE.0)
      ENDIF
C
      PROCESSED=.FALSE.
      DONE=(CUNIT.LE.0.OR.IRC.NE.0)
C
      DO WHILE(.NOT.DONE)
C
C     CHECK IF INPUT IS SPLIT INTO SEVERAL LINES
C
         IF (.NOT. PROCESSED) THEN
C
            IF (SPLIT) THEN
C     LAST LINE WAS SPLIT
            ELSE
               CALL RESET(BUFF,1000)
               CPOS=1
            ENDIF
C
C     ADD TO BUFFER
C
            IF (CPOS.LT.900) THEN
               BUFF(CPOS:CPOS+100)=
     &              STRING(1:100)
               CALL CHOP(BUFF,CPOS+100)
               LENB=LENGTH(BUFF,CPOS+100,CPOS)
            ELSE
               PRE=': E'
               PROCESSED=.TRUE.
               ERROR=.TRUE.
               BUFF='buffer too small (recompile)'
            ENDIF
C
            SPLIT=.FALSE.
C
C     REDEFINE END OF LINE
C
            IF (BUFF(LENB:LENB).EQ.'&') THEN
               SPLIT=.TRUE.
               CPOS=LENB
               BUFF(LENB:LENB)=' '
               PRE=': &'
               PROCESSED=.TRUE.
            ENDIF
         ENDIF
C
C--------CHECK IF THE LINE IS A COMMENT
C
         IF (.NOT. PROCESSED) THEN
            IF (BUFF(1:1).EQ.'#' .OR.
     &           LENB.EQ.0) THEN
               PRE=': #'
               PROCESSED=.TRUE.
            ENDIF
         ENDIF
C
C--------CHECK IF THE LINE STARTS WITH A COMMAND
C
         IF (.NOT.PROCESSED) THEN
            COMMAND=0
            JJ=1
            FOUND=.FALSE.
            DO WHILE(.NOT.FOUND .AND. JJ.LE.MAXCOM)
               FOUND=(CMLEN(JJ).LE.LENB)
               KK=1
               DO WHILE(KK.LE.CMLEN(JJ).AND.FOUND)
                  IF(FOUND) FOUND=(BUFF(KK:KK).EQ.COM20(JJ)(KK:KK))
                  KK=KK+1
               ENDDO
               IF (FOUND)THEN
                  COMMAND=JJ
               ELSE
                  JJ=JJ+1
               ENDIF
            ENDDO
C
C--------PERFORM COMMAND (IF LINE STARTS WITH IT)
C
            IF (COMMAND.NE.0) THEN
C
               PRE=': C'
C
               DONCOM=.FALSE.
               IF (COMMAND.EQ.1) THEN
                  DONCOM=.TRUE.
                  DEL(1)='('
                  DEL(2)=')'
                  LEV=0
                  POS(1)=1
                  POS(2)=1000
                  CALL ITEM(BUFF,1000,DEL,LEV,POS,IRC)
                  CALL RESET(BUFF2,1000)
                  BUFF2=BUFF(1:POS(1)-1)
                  CALL CHOP(BUFF2,1000)
                  LEN2=LENGTH(BUFF2,1000,LEN2)
                  IF (IRC.NE.0) THEN
C     SYNTAX ERROR
                     PRE=': E'
                     PROCESSED=.TRUE.
                     ERROR=.TRUE.
                     BUFF='missing () in if statement.'
                  ELSEIF (COM20(1)(1:CMLEN(1)).EQ.BUFF2(1:LEN2).AND.
     &                    LENB.EQ.POS(2)) THEN
C     ANALYZE TEST VALUE
                     IF ((POS(2)-POS(1)).LE.1) THEN
                        IFVAL=.TRUE.
                     ELSE
                        CALL RESET(BUFF3,1000)
                        BUFF3=BUFF(POS(1)+1:POS(2)-1)
                        CALL EVAL(BUFF3,1000,NRVAR,NAMVAR,
     &                       VALVAR,VARLEN,PPDAT(1,1),IRC)
                        CALL CHOP(BUFF3,1000)
                        LEN3=LENGTH(BUFF3,1000,1)
                        IFVAL=(BUFF3(1:LEN3).EQ.'T')
                     ENDIF
C
                     IFLVL=IFLVL+1
C
                     IF (IFVAL) THEN
                        IFACT(IFLVL)=.TRUE.
                        IFDON(IFLVL)=.TRUE.
                     ELSE
                        IFACT(IFLVL)=.FALSE.
                        IFDON(IFLVL)=.FALSE.
                     ENDIF
C
                  ELSE
C     SYNTAX ERROR
                     PRE=': E'
                     PROCESSED=.TRUE.
                     ERROR=.TRUE.
                     BUFF='strange if statement.'
                  ENDIF
               ELSEIF (COMMAND.EQ.2 .AND. IFLVL.GT.0) THEN
                  DONCOM=.TRUE.
                  IF (.NOT.IFDON(IFLVL)) THEN
                     DEL(1)='('
                     DEL(2)=')'
                     LEV=0
                     POS(1)=1
                     POS(2)=1000
                     CALL ITEM(BUFF,1000,DEL,LEV,POS,IRC)
                     CALL RESET(BUFF2,1000)
                     BUFF2=BUFF(1:POS(1)-1)
                     CALL CHOP(BUFF2,1000)
                     LEN2=LENGTH(BUFF2,1000,LEN2)
                     IF (IRC.NE.0) THEN
C     SYNTAX ERROR
                        PRE=': E'
                        PROCESSED=.TRUE.
                        ERROR=.TRUE.
                        BUFF='missing () in elseif statement.'
                     ELSEIF (COM20(1)(1:CMLEN(1))
     &                       .EQ.BUFF2(1:LEN2).AND.
     &                    LENB.EQ.POS(2)) THEN
C     ANALYZE TEST VALUE
                        IF ((POS(2)-POS(1)).LE.1) THEN
                           IFVAL=.TRUE.
                        ELSE
                           CALL RESET(BUFF3,1000)
                           BUFF3=BUFF(POS(1)+1:POS(2)-1)
                           CALL EVAL(BUFF3,1000,NRVAR,NAMVAR,
     &                          VALVAR,VARLEN,PPDAT(1,1),IRC)
                           CALL CHOP(BUFF3,1000)
                           LEN3=LENGTH(BUFF3,1000,1)
                           IFVAL=(BUFF3(1:LEN3).EQ.'T')
                        ENDIF
C
                        IF (IFVAL) THEN
                           IFACT(IFLVL)=.TRUE.
                           IFDON(IFLVL)=.TRUE.
                        ELSE
                           IFACT(IFLVL)=.FALSE.
                           IFDON(IFLVL)=.FALSE.
                        ENDIF
C
                     ELSE
                        PRE=': E'
                        PROCESSED=.TRUE.
                        ERROR=.TRUE.
                        BUFF='strange elseif statement.'
                     ENDIF
                  ELSE
                     IFACT(IFLVL)=.FALSE.
                  ENDIF
               ELSEIF (COMMAND.EQ.3 .AND. IFLVL.GT.0) THEN
                  DONCOM=.TRUE.
                  IF (.NOT.IFDON(IFLVL)) THEN
                     IFACT(IFLVL)=.TRUE.
                     IFDON(IFLVL)=.TRUE.
                  ELSE
                     IFACT(IFLVL)=.FALSE.
                  ENDIF
               ELSEIF (COMMAND.EQ.4 .AND. IFLVL.GT.0) THEN
                  DONCOM=.TRUE.
                  IFACT(IFLVL)=.FALSE.
                  IFDON(IFLVL)=.FALSE.
                  IFLVL=IFLVL-1
               ENDIF
C
C     MAKE SURE WE REIGSTER NESTING ERRORS
C
               IF (.NOT.DONCOM .AND. COMMAND.LE.4) THEN
                  PRE=': E'
                  PROCESSED=.TRUE.
                  ERROR=.TRUE.
                  BUFF='elseif, else or endif out of place.'
               ENDIF
C
C     COMMANDS ONLY CHECKED IF WE ARE IN AN ACTIVE REGION
C
               GO = (IFLVL.EQ.0)
               IF (.NOT.GO) GO=(IFACT(IFLVL))
C
C     EVALUATE EXPRESSIONS (IN CASE OF ECHO OR INCLUDE)...
C
               IF (GO .AND. .NOT.DONCOM) THEN
                  IF (BDEB) WRITE(*,*) MYNAME,
     &                 'Debug: Calling EVAL.',IRC
                  CALL EVAL(BUFF,1000,NRVAR,NAMVAR,
     &                 VALVAR,VARLEN,PPDAT(1,1),IRC)
                  IF (IRC.NE.0) THEN
                     WRITE(*,*) MYNAME,'Error return from EVAL',IRC
                     RETURN
                  ENDIF
                  LENB=LENGTH(BUFF,1000,LENB)
               ENDIF
C
C               IF ((COMMAND.EQ.5.OR.COMMAND.EQ.6).AND. GO) THEN
C                  DONCOM=.TRUE.
C                  PRE=': E'
C                  PROCESSED=.TRUE.
C                  ERROR=.TRUE.
C                  LENB=LENGTH(BUFF,1000,LENB)
C                  BUFF='Permission denied: '//BUFF(1:LENB)
C               ELSEIF (COMMAND.EQ.5 .AND. GO) THEN
               IF (COMMAND.EQ.5 .AND. GO) THEN
C     EXECUTE UNIX COMMAND
                  DONCOM=.TRUE.
                  IRC1=system(BUFF(2:LENB))
                  IF (IRC1.NE.0) THEN
                     SUCC=.FALSE.
                     IRC1=0
                  ENDIF
               ELSEIF (COMMAND.EQ.6.AND.GO) THEN
C     INCLUDE FILE
                  DONCOM=.TRUE.
                  DEL(1)='('
                  DEL(2)=')'
                  LEV=0
                  POS(1)=1
                  POS(2)=LENB
                  CALL ITEM(BUFF,LENB,DEL,LEV,POS,IRC)
                  IF (IRC.NE.0) THEN
C     SYNTAX ERROR
                     PRE=': E'
                     PROCESSED=.TRUE.
                     ERROR=.TRUE.
                     BUFF='missing () in include statement.'
                  ELSE
                     PATHF=BUFF(POS(1)+1:POS(2)-1)
                     CALL CHOP(PATHF,LENB)
                     IF (CUNIT.LT.MAXUNIT) THEN
                        CUNIT=CUNIT+1
                        LUNIT(CUNIT)=0
                        UNITA(CUNIT)=FTUNIT(IRC)
                        IF (IRC.NE.0) THEN
                           WRITE(*,*) MYNAME,
     &                          'Error return from DEBUG.',IRC
                           RETURN
                        ENDIF
                        OPEN(UNIT=UNITA(CUNIT),FILE=PATHF,
     &                       ACCESS='SEQUENTIAL',FORM='FORMATTED',
     &                       STATUS='OLD',ERR=567)
                        FILES(CUNIT)=PATHF(1:100)
                        GOTO 568
 567                    CONTINUE
                        CUNIT=CUNIT-1
                        LENF=LENGTH(PATHF,100,10)
                        PRE=': E'
                        PROCESSED=.TRUE.
                        ERROR=.TRUE.
                        BUFF='corrupted file: '//PATHF(1:LENF)
 568                    CONTINUE
                     ELSE
                        LENF=LENGTH(PATHF,100,10)
                        PRE=': E'
                        PROCESSED=.TRUE.
                        ERROR=.TRUE.
                        BUFF='too deep file structure: '//
     &                       PATHF(1:LENF)
                     ENDIF
                  ENDIF
               ELSEIF (COMMAND.EQ.7.AND.GO) THEN
C     STOP COMMAND
                  GOTO 200
               ELSEIF (COMMAND.EQ.8.AND.GO) THEN
C     EXIT COMMAND
                  DONCOM=.TRUE.
                  JUNK=NUKEHEAD(BUFF,100)
                  READ(BUFF,*,ERR=10,END=10) IRC
 10               CALL exit(IRC)
               ELSEIF (COMMAND.EQ.9.AND.GO) THEN
C     WRITE COMMAND
                  DONCOM=.TRUE.
                  JUNK=NUKEHEAD(BUFF,100)
                  CALL CHOP(BUFF,LENB)
                  LENB=LENGTH(BUFF,LENB,LENB)
                  WRITE(*,*) BUFF(1:LENB)
               ELSEIF (COMMAND.EQ.10 .AND. GO) THEN
C     SET COMMAND
                  DONCOM=.TRUE.
C     IDENTIFY ALL EQUAL SIGNS
                  COMP=.FALSE.
                  CEQN=0
                  LENB=LENGTH(BUFF,1000,LENB)
                  DO II=1,LENB
                     IF (BUFF(II:II).EQ.'=') THEN
                        CEQN=CEQN+1
                        POSEQN(CEQN)=II
                     ENDIF
                  ENDDO
C
C     LOOP THROUGH ALL EQUATIONS
C
                  IF (CEQN.GT.0) THEN
C     FOUND AT LEAST ONE '='
                     DO KK=CEQN,1,-1
C
                        IF (KK.GT.1) THEN
                           POS(1)=POSEQN(KK-1)+1
                        ELSE
                           POS(1)=4
                        ENDIF
C
                        IF (KK.LT.CEQN) THEN
                           POS(2)=POSEQN(KK+1)-1
                        ELSE
                           POS(2)=1000
                        ENDIF
C
C     GET PART OF STRING BEFORE AND AFTER '='
C
                        CALL RESET(BUFF2,1000)
                        BUFF2=BUFF(POS(1):POSEQN(KK)-1)
                        IF (BDEB) WRITE(*,*) MYNAME,
     &                       'Debug: Calling EVAL.',IRC
                        CALL EVAL(BUFF2,1000,NRVAR,NAMVAR,
     &                       VALVAR,VARLEN,PPDAT(1,1),IRC)
                        CALL CHOP(BUFF2,1000)
                        LEN2=LENGTH(BUFF2,100,LEN2)
                        CALL RESET(BUFF3,1000)
                        BUFF3=BUFF(POSEQN(KK)+1:POS(2))
                        IF (BDEB) WRITE(*,*) MYNAME,
     &                       'Debug: Calling EVAL.',IRC
                        CALL EVAL(BUFF3,1000,NRVAR,NAMVAR,
     &                       VALVAR,VARLEN,PPDAT(1,1),IRC)
                        CALL CHOP(BUFF3,1000)
                        LEN3=LENGTH(BUFF3,100,LEN3)
C
C     FIND OUT IF VARIABLE EXISTS
C
                        II=0
                        FOUND=.FALSE.
                        DO WHILE (II.LT.NRVAR .AND. .NOT.FOUND)
                           II=II+1
                           JJ=0
                           FOUND=(VARLEN(II).EQ.LEN2.AND.LEN2.NE.0)
                           DO WHILE (JJ.LT.LEN2 .AND. FOUND)
                              JJ=JJ+1
                              IF (FOUND) FOUND=(BUFF2(JJ:JJ).EQ.
     &                             NAMVAR(II)(JJ:JJ))
                           ENDDO
                        ENDDO
                        CVAR=II
C
                        LEN3=MIN(LEN3,1)
                        IF (BUFF3(1:LEN3).EQ.'.'.OR.
     &                       BUFF3(1:LEN3).EQ.C1) THEN
                           IF (FOUND) THEN
C     REMOVE VARIABLE
                              NAMVAR(CVAR)=NAMVAR(NRVAR)
                              VALVAR(CVAR)=VALVAR(NRVAR)
                              VARLEN(CVAR)=VARLEN(NRVAR)
                              NRVAR=NRVAR-1
                           ELSE
                              PRE=': E'
                              PROCESSED=.TRUE.
                              ERROR=.TRUE.
                              BUFF='attempt to remove non-existent'//
     &                          ' variable.'
                           ENDIF
                        ELSE
C     ADD/UPDATE VARIABLE
                           IF (FOUND) THEN
                              VALVAR(CVAR)=BUFF3(1:100)
                           ELSE
                              IF (NRVAR.LT.MAXVAR) THEN
                                 NRVAR=NRVAR+1
                                 NAMVAR(NRVAR)=BUFF2(1:100)
                                 VALVAR(NRVAR)=BUFF3(1:100)
                                 VARLEN(NRVAR)=
     &                                LENGTH(NAMVAR(NRVAR),100,5)
                              ENDIF
                           ENDIF
                        ENDIF
                     ENDDO
                  ENDIF
               ELSEIF (COMMAND.EQ.11 .AND. GO) THEN
C     IMPORT
                  DONCOM=.TRUE.
C     FIRST REMOVE THE ACTUAL COMMAND...
                  BUFF2=NUKEHEAD(BUFF,100)
C     READ THE FIRST ARGUMENT...
                  BUFF2=NUKEHEAD(BUFF,100)
                  CALL CHOP(BUFF2,1000)
                  LEN2=LENGTH(BUFF2,100,LEN2)
                  BDONE = (LEN2.LE.0)
                  DO WHILE (.NOT. BDONE)
                     IF (BDEB) WRITE(*,*) MYNAME,
     &                    'Debug: Calling EVAL.',IRC
                     CALL EVAL(BUFF2,1000,NRVAR,NAMVAR,
     &                    VALVAR,VARLEN,PPDAT(1,1),IRC)
                     CALL CHOP(BUFF2,1000)
                     LEN2=LENGTH(BUFF2,100,LEN2)
                     CALL RESET(BUFF3,1000)
C     IMPORT ENVIRONMENT VARIABLE FROM SHELL...
                     call getenv(buff2(1:len2),buff3)
                     IF (BDEB) WRITE(*,*) MYNAME,
     &                    'Debug: Calling EVAL.',IRC
C                     CALL EVAL(BUFF3,1000,NRVAR,NAMVAR,
C     &                    VALVAR,VARLEN,PPDAT(1,1),IRC)
                     CALL CHOP(BUFF3,1000)
                     LEN3=LENGTH(BUFF3,100,LEN3)
C
C     FIND OUT IF VARIABLE EXISTS
C
                     II=0
                     FOUND=.FALSE.
                     DO WHILE (II.LT.NRVAR .AND. .NOT.FOUND)
                        II=II+1
                        JJ=0
                        FOUND=(VARLEN(II).EQ.LEN2.AND.LEN2.NE.0)
                        DO WHILE (JJ.LT.LEN2 .AND. FOUND)
                           JJ=JJ+1
                           IF (FOUND) FOUND=(BUFF2(JJ:JJ).EQ.
     &                          NAMVAR(II)(JJ:JJ))
                        ENDDO
                     ENDDO
                     CVAR=II
C
                     LEN3=MIN(LEN3,1)
                     IF (BUFF3(1:LEN3).EQ.'.'.OR.
     &                    BUFF3(1:LEN3).EQ.C1) THEN
                        IF (FOUND) THEN
C     REMOVE VARIABLE
                           NAMVAR(CVAR)=NAMVAR(NRVAR)
                           VALVAR(CVAR)=VALVAR(NRVAR)
                           VARLEN(CVAR)=VARLEN(NRVAR)
                           NRVAR=NRVAR-1
                        ELSE
                           PRE=': E'
                           PROCESSED=.TRUE.
                           ERROR=.TRUE.
                           BUFF='attempt to remove non-existent'//
     &                          ' variable.'
                        ENDIF
                     ELSE
C     ADD/UPDATE VARIABLE
                        IF (FOUND) THEN
                           VALVAR(CVAR)=BUFF3(1:100)
                        ELSE
                           IF (NRVAR.LT.MAXVAR) THEN
                              NRVAR=NRVAR+1
                              NAMVAR(NRVAR)=BUFF2(1:100)
                              VALVAR(NRVAR)=BUFF3(1:100)
                              VARLEN(NRVAR)=
     &                             LENGTH(NAMVAR(NRVAR),100,5)
                           ENDIF
                        ENDIF
                     ENDIF
C
C     READ THE NEXT ARGUMENT...
C
                     IF (ERROR) THEN
                        BDONE=.TRUE.
                     ELSE
                        BUFF2=NUKEHEAD(BUFF,100)
                        CALL CHOP(BUFF2,1000)
                        LEN2=LENGTH(BUFF2,100,LEN2)
                        BDONE = (LEN2.LE.0)
                     END IF
                  END DO
               ELSEIF (COMMAND.EQ.12 .AND. GO) THEN
C     EXPORT
                  DONCOM=.TRUE.
C     FIRST REMOVE THE ACTUAL COMMAND...
                  BUFF2=NUKEHEAD(BUFF,100)
C     READ THE FIRST ARGUMENT...
                  BUFF2=NUKEHEAD(BUFF,100)
                  CALL CHOP(BUFF2,1000)
                  LEN2=LENGTH(BUFF2,100,LEN2)
                  BDONE = (LEN2.LE.0)
                  DO WHILE (.NOT. BDONE)
                     IF (BDEB) WRITE(*,*) MYNAME,
     &                    'Debug: Calling EVAL.',IRC
                     CALL EVAL(BUFF2,1000,NRVAR,NAMVAR,
     &                    VALVAR,VARLEN,PPDAT(1,1),IRC)
                     CALL CHOP(BUFF2,1000)
                     LEN2=LENGTH(BUFF2,100,LEN2)
C
C     FIND OUT IF VARIABLE EXISTS
C
                     II=0
                     FOUND=.FALSE.
                     DO WHILE (II.LT.NRVAR .AND. .NOT.FOUND)
                        II=II+1
                        JJ=0
                        FOUND=(VARLEN(II).EQ.LEN2.AND.LEN2.NE.0)
                        DO WHILE (JJ.LT.LEN2 .AND. FOUND)
                           JJ=JJ+1
                           IF (FOUND) FOUND=(BUFF2(JJ:JJ).EQ.
     &                          NAMVAR(II)(JJ:JJ))
                        ENDDO
                     ENDDO
                     CVAR=II
C
                     IF (FOUND) THEN
C     EXPORT VARIABLE TO SHELL...
                        BUFF3=VALVAR(CVAR)
                        IF (BDEB) WRITE(*,*) MYNAME,
     &                       'Debug: Calling EVAL.',IRC
                        CALL EVAL(BUFF3,1000,NRVAR,NAMVAR,
     &                       VALVAR,VARLEN,PPDAT(1,1),IRC)
                        CALL CHOP(BUFF3,1000)
                        LEN3=LENGTH(BUFF3,100,LEN3)
                        BUFF3=BUFF2(1:LEN2)//'='//BUFF3(1:LEN3)
                        CALL CHOP(BUFF3,1000)
                        LEN3=LENGTH(BUFF3,100,LEN3)
                        IRC1=putenv(BUFF3(1:LEN3))
                        IF (IRC1.NE.0) THEN
                           SUCC=.FALSE.
                           IRC1=0
                        ENDIF
                     ELSE
                        PRE=': E'
                        PROCESSED=.TRUE.
                        ERROR=.TRUE.
                        BUFF='attempt to export non-existent'//
     &                       ' variable.'
                     ENDIF
C
C     READ THE NEXT ARGUMENT...
C
                     IF (ERROR) THEN
                        BDONE=.TRUE.
                     ELSE
                        BUFF2=NUKEHEAD(BUFF,100)
                        CALL CHOP(BUFF2,1000)
                        LEN2=LENGTH(BUFF2,100,LEN2)
                        BDONE = (LEN2.LE.0)
                     END IF
                  END DO
               ENDIF
               IF (DONCOM) PROCESSED=.TRUE.
            ENDIF
         ENDIF
C
C     MAKE SURE WE DISREGARD LINES IF WE ARE IN WRONG PART OF IF-TEST
C
         IF (IFLVL.GT.0.AND..NOT.PROCESSED.AND..NOT.GO) THEN
            PRE=': #'
            PROCESSED=.TRUE.
         ENDIF
C
C--------CHECK IF THE LINE IS A HELP STATEMENT
C
         IF (.NOT. PROCESSED) THEN
            IF (BUFF(1:1).EQ.'?') THEN
C     LIST ALL HEADERS
               WRITE(*,*) MYNAME,
     &              '--------LIST OF POSSIBLE HEADERS--------'
               DO II=1,NRHDR
                  LENS=LENGTH(HDR100(II),100,NRLEN(II)+3)
                  IF(ACTHDR(II))
     &                 WRITE(*,*) HDR100(II)(1:LENS)
               ENDDO
               WRITE(*,*) MYNAME,
     &              '--------LIST OF POSSIBLE COMMANDS-------'
               DO II=1,MAXCOM
                  LENS=LENGTH(COM20(II),20,3)
                  LENH=LENGTH(HLP20(II),20,3)
                  WRITE(*,*) COM20(II)(1:LENS)//' '//
     &                 HLP20(II)(1:LENH)
               ENDDO
               WRITE(*,*) MYNAME,
     &              '----------------------------------------'
               PRE=': ?'
               PROCESSED=.TRUE.
            ENDIF
         ENDIF
C
C--------CHECK IF THIS LINE IS A HEADER
C
         IF (.NOT.PROCESSED) THEN
            JJ=1
            FOUND=.FALSE.
            DO WHILE(.NOT.FOUND .AND. JJ.LE.MAXHDR)
               FOUND=((NRLEN(JJ).LE.LENB).AND.(ACTHDR(JJ)))
               KK=1
               DO WHILE(KK.LE.NRLEN(JJ).AND.FOUND)
                  IF(FOUND) FOUND=(BUFF(KK:KK).EQ.HDR100(JJ)(KK:KK))
                  KK=KK+1
               ENDDO
               IF (FOUND)THEN
C
C     CHECK IF WE ARE INTERUPTING ANOTHER DATA BODY
C
                  IF (RDATA) THEN
                     IF (CNT.NE.CODHDR(LINE)
     &                    .AND. CODHDR(LINE).NE.-1) THEN
                        PRE=': E'
                        PROCESSED=.TRUE.
                        ERROR=.TRUE.
                        BUFF='header in data body'
                     ENDIF
                  ENDIF
C
                  IF (.NOT.ERROR) THEN
C
C     PREPARE FOR DATABODY IF FIXED NUMBER OF DATA LINES
C
                     IF (CODHDR(JJ).NE.0) THEN
                        CNT=0
                        RDATA=.TRUE.
                     ELSE
                        RDATA=.FALSE.
                        CURHDR=CURHDR+1
                        INTOUT(CURHDR)=JJ
                        CALL RESET(DAT100(CURHDR),100)
                        IF (CURHDR.EQ.NRDAT) THEN
                           DONE=.TRUE.
                        ELSE
                           INTOUT(CURHDR+1)=0
                        ENDIF
                     ENDIF
                     LINE=JJ
                     PRE=': H'
                     PROCESSED=.TRUE.
                  ENDIF
               ELSE
                  JJ=JJ+1
               ENDIF
            ENDDO
         ENDIF
C
C--------CHECK IF THIS LINE SHOULD BE TREATED AS DATA BODY
C
         IF (.NOT.PROCESSED) THEN
            IF (RDATA) THEN
C
               PRE=': D'
               PROCESSED=.TRUE.
C
C     PRE-PROCESS LINE IF THIS IS REQUIRED
C
               IF (BDEB) WRITE(*,*) MYNAME,'Debug: Calling EVAL.',IRC
               CALL EVAL(BUFF,1000,NRVAR,NAMVAR,VALVAR,VARLEN,
     &              PPDAT(1,LINE),IRC)
               LENB=LENGTH(BUFF,1000,LENB)
C
               IF (LENB.EQ.0) THEN
C     DATA LINE IS EMPTY
                  WRITE(*,*) MYNAME,
     &                 'Warning: empty data line found under: '//
     &                 HDR100(LINE)(1:NRLEN(LINE))
               END IF
C
C     STORE DATA LINE
C
               IF (CODHDR(LINE).NE.0) THEN
C
                  CURHDR=CURHDR+1
                  INTOUT(CURHDR)=LINE
                  DAT100(CURHDR)=BUFF(1:100)
C
                  IF (CODHDR(LINE).GT.0) CNT=CNT+1
C
                  IF (CNT.EQ.CODHDR(LINE)) THEN
                     LINE=0
                     CNT=0
                     RDATA=.FALSE.
                  ENDIF
C
C     SET INDEX OF NEXT DATA BODY=0 (IN CASE THIS LINE IS THE LAST ONE)
C
                  IF (CURHDR.EQ.NRDAT) THEN
                     DONE=.TRUE.
                  ELSE
                     INTOUT(CURHDR+1)=0
                  ENDIF
               ENDIF
            ENDIF
         ENDIF
C
C     DEBUG DUMP
C
         IF (BDEB) THEN
            CALL RESET(DUMP,100)
            IF (LENF.GT.80)LENF=80
            IF (LUNIT(CUNIT).EQ.0 .AND.CUNIT.GT.1) THEN
               CALL CHOP(FILES(CUNIT-1),100)
               LENF=LENGTH(FILES(CUNIT-1),100,10)
               WRITE(DUMP,*)
     &              '\"'//FILES(CUNIT-1)(1:LENF)//'\", line ',
     &              LUNIT(CUNIT-1),PRE,':'
            ELSE
               CALL CHOP(FILES(CUNIT),100)
               LENF=LENGTH(FILES(CUNIT),100,10)
               WRITE(DUMP,*) '\"'//FILES(CUNIT)(1:LENF)//'\", line ',
     &              LUNIT(CUNIT),PRE,':'
            ENDIF
            CALL CHOP(DUMP,100)
            LEND=LENGTH(DUMP,80,10)
            DUMP(LEND+1:LEND+1)=' '
            LENB=100-LEND-2
            WRITE(DUMP(LEND+2:100),*)STRING(1:LENB)
            CALL CHOP(DUMP,100)
            LEND=LENGTH(DUMP,100,LEND)
            WRITE(*,*) DUMP(1:LEND)
         ENDIF
C
C     IF WE'RE STILL NOT PROCESSED, SOMETHING IS WRONG
C
         IF (.NOT.PROCESSED .OR. ERROR) THEN
            CALL RESET(DUMP,100)
            CALL CHOP(FILES(CUNIT),100)
            LENF=LENGTH(FILES(CUNIT),100,10)
            IF (LENF.GT.80)LENF=80
            WRITE(DUMP,*) '\"'//FILES(CUNIT)(1:LENF)//'\", line ',
     &           LUNIT(CUNIT),': Error: '
            CALL CHOP(DUMP,100)
            LEND=LENGTH(DUMP,80,10)
            DUMP(LEND+1:LEND+1)=' '
            LENB=100-LEND-2
            WRITE(DUMP(LEND+2:100),*)BUFF(1:LENB)
            CALL CHOP(DUMP,100)
            LEND=LENGTH(DUMP,100,LEND)
            WRITE(*,*) DUMP(1:LEND)
            SUCC=.FALSE.
         ENDIF
C
         PROCESSED=.FALSE.
         ERROR=.FALSE.
C
 198     CONTINUE
         LUNIT(CUNIT)=LUNIT(CUNIT)+1
         READ(UNITA(CUNIT),'(A100)',ERR=200,END=200) STRING
         GOTO 205
 200     CONTINUE
         IF (UNITA(CUNIT).GT.30) CLOSE(UNITA(CUNIT))
C     CHECK IF END OF LINE INERRUPTED A DATA BODY
         IF (CUNIT.EQ.1.AND.CNT.NE.0) THEN
            BUFF='End of file interrupts data body.'
            CALL RESET(DUMP,100)
            CALL CHOP(FILES(CUNIT),100)
            LENF=LENGTH(FILES(CUNIT),100,10)
            IF (LENF.GT.80)LENF=80
            WRITE(DUMP,*) '\"'//FILES(CUNIT)(1:LENF)//'\", line ',
     &           LUNIT(CUNIT),': Error: '
            CALL CHOP(DUMP,100)
            LEND=LENGTH(DUMP,80,10)
            DUMP(LEND+1:LEND+1)=' '
            LENB=100-LEND-2
            WRITE(DUMP(LEND+2:100),*)BUFF(1:LENB)
            CALL CHOP(DUMP,100)
            LEND=LENGTH(DUMP,100,LEND)
            WRITE(*,*) DUMP(1:LEND)
            SUCC=.FALSE.
         ELSEIF (CUNIT.LE.0) THEN
            WRITE(*,*) MYNAME,'Internal error, file nesting.'
            IRC=103
            CALL exit(IRC)
         ENDIF
         CUNIT=CUNIT-1
C     READ NEXT LINE IN PREVIOUS FILE
         IF (CUNIT.GT.0) GOTO 198
C     END OF INPUT FILE HAS BEEN REACHED...
         IF (INTOUT(1).EQ.0 .OR. IRC.NE.0) THEN
            DONE=.TRUE.
            FIRST=.TRUE.
         END IF
 205     CONTINUE
C
      ENDDO
C
      IF (.NOT.SUCC .AND. IRC.EQ.0) IRC=104
C
 998  FORMAT(X,A8,I5,A3,A40)
C
      IF (BDEB) WRITE(*,*) MYNAME,'Debug: Routine ends.',IRC
C
      RETURN
      END
#__mcat: nukecp.F     **DO NOT DELETE
      SUBROUTINE NUKECP(STRING,ST1,ST2,N)
C     ***********************************************************************
C     +                                                                     *
C     REPLACES ST1 BY ST2 IN STRING (WITH LENGTH N)
C     +                                                                     *
CIO   STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    ST1 (C*1) = CHARACTER(S) WHICH SHOULD BE REMOVED FROM STRING          *
CI    ST2 (C*1) = CHARACTER WHICH SHOULD REPLACE ST1                        *
CI    N (I*4) = LENGTH OF STRING                                            *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N
      CHARACTER*(*) STRING
      CHARACTER*1 ST1,ST2
      INTEGER*4 II,LENS,LENGTH
      EXTERNAL LENGTH
C
      LENS=LENGTH(STRING,N,1)
C
      DO II=1,LENS
         IF (STRING(II:II).EQ.ST1) STRING(II:II)=ST2
      ENDDO
C
      CALL CHOP(STRING,LENS)
C
      RETURN
      END
#__mcat: nukehead.F     **DO NOT DELETE
      CHARACTER*100 FUNCTION NUKEHEAD(STRING,N)
C     ***********************************************************************
C     +                                                                     *
C     FUNCTION RETURNS THE FIRST ITEM IN STRING,                            *
C     AND REMOVES IT FROM STRING                                            *
C     +                                                                     *
CIO   STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    N (I*4) = LENGTH OF STRING                                            *
CO    NUKEHEAD (C*100) = HEAD OF STRING                                     *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N
      CHARACTER*1 STRING(N),C1
C
      CHARACTER*100 OUT
      INTEGER*4 CRR,II,JJ
      LOGICAL*4 BLNK,FIRST
      DATA FIRST /.TRUE./
      CHARACTER*8 MYNAME
      DATA MYNAME /'NUKEHEAD'/
C
      IF (FIRST) THEN
         C1=CHAR(0)
         FIRST=.FALSE.
      ENDIF
C
C     CRR = CURRENT POINTER POSITION IN STRING
      CRR=0
C
      BLNK=.FALSE.
C
      DO WHILE (.NOT.BLNK .AND. CRR.LT.N)
         CRR = CRR+1
         BLNK= (STRING(CRR) .EQ. ' ')
      ENDDO
C
      CALL RESET(OUT,100)
      IF (BLNK) THEN
C     SEVERAL ITEMS IN STRING
         JJ=MIN(100,CRR)
         DO II=1,JJ
            OUT(II:II)=STRING(II)
         ENDDO
         JJ=N-CRR
         DO II=1,JJ
            STRING(II)=STRING(II+CRR)
         ENDDO
         DO II=JJ+1,N
            STRING(II)=C1
         ENDDO
      ELSE
C     JUST ONE ITEM IN STRING
         JJ=MIN(100,N)
         DO II=1,JJ
            OUT(II:II)=STRING(II)
         ENDDO
         DO II=1,N
            STRING(II)=C1
         ENDDO
      ENDIF
C
      CALL CHOP(OUT,100)
      CALL CHOP(STRING,N)
C
      NUKEHEAD=OUT
      RETURN
      END
#__mcat: nukem.F     **DO NOT DELETE
      SUBROUTINE NUKEM(KODE,UNITI,HDR100,INTOUT,DAT100,
     &     ENDOFF,IRC)
C     ***********************************************************************
C     +                                                                     *
C     INTERFACE SUBROUTINE TO FORTRAN-PROGRAM INPUT FILES                   *
C     +                                                                     *
CI    KODE (I*4) = INITIALISATION CODE,                                     *
C     +     KODE=-1 REINITIALISES                                           *
C     +     KODE=0 READ A DATA-BODY ITEM                                    *
C     +     KODE=-1 TERMINATE READING                                       *
CI    UNITI (I*4) = UNIT NUMBER FOR INPUT FILE (5=STANDARD INPUT)           *
CI    HDR100(100) (C*100) = HEADERS TO SEARCH FOR IN INPUT FILE             *
C     +   HEADER MUST BE ON FORM 'THIS IS THE HEADER [N]P', WHERE N         *
C     +   IS THE NUMBER OF LINES INCLUDED IN DATA LINE (CONCATENATED).      *
C     +   IF 'N'='*' THEN ONE DATA LINE IS RETURNED PER LINE IN THE FILE    *
C     +   (NOTE: THE HEADER IS IN THIS CASE ONLY NEEDED ONCE).              *
C     +   A 'P' AT THE END IMPLIES THAT THE DATA SHOULD BE PREPROCESSED.    *
CO    INTOUT (I*4) = HEADER ID (LOC IN ARRAY) FOR DATA FOUND IN FILE *
CO    DAT100 (C*100) = DATA BODY                                     *
C     +      II=INTOUT(JJ) => HEADER HDR100(II) HAD DATABODY DAT100(JJ)     *
CIO   IRC (I*4) = ERROR RETURN CODE (IRC=0, ALL OK)                         *
C     +     A CALL WITH (IRC.NE.0) WILL INITIALISE THE ROUTINE              *
C     +                                                                     *
C     NOTE :                                                                *
C     +   o THE LINE '?' IN INPUT FILE WILL LIST ALL HEADERS AND COMMANDS   *
C     +   o IT IS POSSIBLE TO BYPASS THE MATHEMATICAL PREPROCESSOR          *
C     +     (IF IT FAILS TO WORK). IF THE MATHEMATICAL EXPRESSION IS        *
C     +     CONTAINED IN {}, IT WILL NOT BE EVALUATED ({} ARE DELETED), AN  *
C     +     ALTERNATIVE IS [] ([] ARE CONVERTED INTO ()).                   *
C     +                                                                     *
C     EXAMPLE OF CALL SEQUENCE :                                            *
C     +                                                                     *
C     INTEGER*4 IRC,KODE,UNITI                                              *
C     CHARACTER*100 HDR100(100),DAT100                                      *
C     INTEGER*4 INTOUT                                                      *
C     LOGICAL*4 ENDOFF                                                      *
C     UNITI=5                                                               *
C     HDR100(1)='THIS IS A HEADER : [*]P'                                   *
C     KODE=-1                                                               *
C     CALL NUKEM(KODE,UNITI,HDR100,INTOUT,DAT100,ENDOFF,IRC)                *
C     KODE=0                                                                *
C     CALL NUKEM(KODE,UNITI,HDR100,INTOUT,DAT100,ENDOFF,IRC)                *
C     KODE=+1                                                               *
C     CALL NUKEM(KODE,UNITI,HDR100,INTOUT,DAT100,ENDOFF,IRC)                *
C     +                                                                     *
C     EXAMPLE OF INPUT FILE (THE 'C     ' AND '*' SHOULD BE IGNORED)        *
C     +                                                                     *
C     # first line (comment)                                                *
C     # test input file (yet another comment)                               *
C       THIS IS A HEADER :                                                  *
C        data-string data1                                                  *
C        1+2 +1.0D-4^-2 +23/1.01D2 +(1*(-1*(1*(-1*(1*(-2)))))) data2        *
C     # (...and another comment) The next line gives (some) help            *
C        ?                                                                  *
C     # last line (last comment)                                            *
C     +                                                                     *
C     THE DATA IN THE ABOVE FILE IS INTERPRETED AS :                        *
C     data-string data1                                                     *
C     3 +100000000. +0.22772277227723 +(-2) data2                           *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 MAXHDR
      PARAMETER (MAXHDR=100)
C
C     INTERFACE VARIABLES
C
      INTEGER*4 KODE,UNITI
      CHARACTER*100 HDR100(MAXHDR),DAT100
      INTEGER*4 INTOUT,IRC
      LOGICAL*4 ENDOFF
C
C     INTERNAL VARIABLES
C
      LOGICAL*4 LFLDAT(MAXHDR) ! 
      INTEGER*4 NROPT, MAXGRP
      PARAMETER (NROPT=5,MAXGRP=5)
      LOGICAL*4 PPDAT(NROPT,MAXHDR)
      LOGICAL*4 ACTHDR(MAXHDR)
      INTEGER*4 NRLEN(MAXHDR),CODHDR(MAXHDR),NRHDR,CURHDR
      INTEGER*4 HDRGRP(2,MAXGRP,MAXHDR),NRGRP
      LOGICAL*4 IENDOFF
C
      INTEGER*4 MAXCOM,NRCOM,
     &     LENGTH,LENB,LENF,MEAN
      PARAMETER (MAXCOM=12)
      CHARACTER*20 COM20(MAXCOM),HLP20(MAXCOM)
      CHARACTER*100 NUKEHEAD
      CHARACTER*1000 BUFF1000,PATHF
      EXTERNAL FTUNIT,LENGTH
      INTEGER*4 CMLEN(MAXCOM),system,putenv,FTUNIT
      EXTERNAL system,putenv
C
      INTEGER*4    LINE,CNT
C
      LOGICAL*4 BDONE,PROCESS
C
C     AUXILIARY VARIABLES
C
      INTEGER*4 MAXVAR,IFLVL
      PARAMETER (MAXVAR=50)
      INTEGER*4 VARLEN(MAXVAR),NRVAR
      CHARACTER*100 NAMVAR(MAXVAR),VALVAR(MAXVAR)
C
C     UNIT CONTROLLERS
C
      INTEGER*4 MAXUNIT
      PARAMETER (MAXUNIT=10)
      INTEGER*4 UNITA(MAXUNIT),CUNIT,LUNIT(MAXUNIT),II
      CHARACTER*100 FILES(MAXUNIT)
C
C     EQUAL SIGN IDENTIFIERS
C
      CHARACTER*8 MYNAME
      DATA MYNAME /'NUKEM'/
      LOGICAL*4 BDEB,ACTIVE,INITIALISED
      DATA ACTIVE /.FALSE./
      DATA INITIALISED /.FALSE./
C
C     Debug System.
C
      IF (.NOT.ACTIVE) CALL DEBUG(MYNAME,BDEB,ACTIVE)
C
      IF (BDEB) WRITE(*,*) MYNAME,'Debug: Routine starts.',IRC
C
      INTOUT=0
C
      IF (KODE.EQ.-1) THEN
         IF (INITIALISED) THEN
            WRITE(*,*) MYNAME,'ROUTINE IS ALLREADY INITIALISED'
            IRC=42
            RETURN
         END IF
C
C     INITIALISE
C
         LINE=-1
         KODE=0
         ENDOFF=.FALSE.
         NRGRP=0
         IFLVL=0
C
C     C1=CHAR(0)
C
C     DEFINE COMMANDS
C
         CALL GETCOM(MAXCOM,NRCOM,COM20,HLP20,CMLEN,IRC)
C     
C     ANALYZE HEADERS
C
         CALL ANAHDR(MAXHDR,NRHDR,HDR100,ACTHDR,NRLEN,
     &        CODHDR,PPDAT,MAXGRP,NRGRP,HDRGRP,
     &        IRC)
C
         IF (IRC.NE.0) THEN
            WRITE(*,*) MYNAME,'Error return from ANAHDR.',IRC
            RETURN
         END IF
C
         DO II=1,NRHDR
            LFLDAT(II)=.FALSE.
         END DO
C
C     GET FIRST LINE
C
         CNT=0
         CUNIT=1
         UNITA(CUNIT)=UNITI
         FILES(CUNIT)='input file'
         CALL CHOP(FILES(CUNIT),100)
         LENF=LENGTH(FILES(CUNIT),100,10)
C
         IENDOFF=.FALSE.
         CALL GETLINE(MAXUNIT,UNITA,FILES,LUNIT,CUNIT,
     &        CNT,MAXHDR,CODHDR,LINE,
     &        BUFF1000,LENB,IENDOFF,IRC)
C
         IF (IRC.NE.0) THEN
            WRITE(*,*) MYNAME,'Error return from GETLINE.',IRC
            RETURN
         END IF
C
         IF (IENDOFF) THEN
            IRC=266
            WRITE(*,*) MYNAME,
     &           'Use the "?" command in the input file '//
     &           'to list the possible headers.'
            WRITE(*,'(A)') '#'
            WRITE(*,'(A)') ' ?'
            WRITE(*,'(A)') '#'
            WRITE(*,*) MYNAME,'Input file is empty.',IRC
            RETURN
         END IF
C
         INITIALISED = .TRUE.
C
      ELSE IF (KODE.EQ.0) THEN  ! analyse next line
C
         IF (.NOT.INITIALISED) THEN
            WRITE(*,*) MYNAME,'ROUTINE NEEDS TO BE INITIALISED'
            IRC=44
            RETURN
         END IF
C
         INTOUT=0
         DAT100=''
         BDONE=IENDOFF
         DO WHILE (.NOT.BDONE)
C
            PROCESS=.TRUE.
C
C     CHECK FOR COMMAND
C
            CALL QCOM(MAXCOM,NRCOM,COM20,HLP20,CMLEN,PPDAT,
     &           MAXUNIT,UNITA,FILES,LUNIT,CUNIT,
     &           MAXHDR,NRHDR,HDR100,ACTHDR,NRLEN,
     &           MAXVAR,NRVAR,NAMVAR,VALVAR,VARLEN,IFLVL,
     &           BUFF1000,LENB,PROCESS,BDONE,IENDOFF,IRC)
C
            IF (IRC.NE.0) THEN
               WRITE(*,*) MYNAME,'Error return from QCOM.',
     &              IRC
               RETURN
            END IF
C     
C     CHECK IF HAVE A HEADER
C
            IF (PROCESS) THEN
               CALL QHDR(MAXUNIT,FILES,LUNIT,CUNIT,
     &              MAXHDR,NRHDR,HDR100,ACTHDR,NRLEN,
     &              LFLDAT,INTOUT,CNT,CODHDR,LINE,
     &              BUFF1000,LENB,PROCESS,BDONE,IRC)
C
               IF (IRC.NE.0) THEN
                  WRITE(*,*) MYNAME,'Error return from QHDR.',
     &                 IRC
                  RETURN
               END IF
C
            END IF
C
C     CHECK IF WE SHOULD STORE AS A DATA-BODY
C
            IF (PROCESS) THEN
               CALL QBDY(MAXUNIT,FILES,LUNIT,CUNIT,
     &              MAXHDR,HDR100,NRLEN,PPDAT,INTOUT,
     &              CNT,CODHDR,LINE,DAT100,
     &              MAXVAR,NRVAR,NAMVAR,VALVAR,VARLEN,
     &              BUFF1000,LENB,PROCESS,BDONE,IRC)
C
               IF (IRC.NE.0) THEN
                  WRITE(*,*) MYNAME,'Error return from QBDY.',
     &                 IRC
                  RETURN
               END IF
C
            END IF
C
C     WRITE ERROR MESSAGE IF WE WERE NOT ABLE TO PROCESS LINE
C
            IF (PROCESS) THEN
               
               WRITE(*,*) MYNAME,
     &              '"'//FILES(CUNIT)(1:LENF)//'", line ',
     &              LUNIT(CUNIT),': Error: Unable to interpret:',
     &              BUFF1000(1:LENB)
               IRC=999
               RETURN
            END IF
C
C     GET NEXT LINE IF NOT EOF
C
            IF (.NOT.IENDOFF) THEN ! we may have encountered a "stop" statement
               CALL GETLINE(MAXUNIT,UNITA,FILES,LUNIT,CUNIT,
     &              CNT,MAXHDR,CODHDR,LINE,
     &              BUFF1000,LENB,IENDOFF,IRC)
C
               IF (IRC.NE.0) THEN
                  WRITE(*,*) MYNAME,'Error return from GETLINE.',
     &                 IRC
                  RETURN
               END IF
C
            END IF
C
            IF (IENDOFF) THEN   ! ok, wrap it up...
               BDONE=.TRUE.
               IF (CNT.EQ.0 .AND. CODHDR(LINE).EQ.-1) THEN
                  LINE=-1
                  INTOUT=0
               END IF
            END IF
C     
         END DO
C
C     REPORT EOF IF WE ARE RETURNING DATA...
C
         ENDOFF=IENDOFF
C
         IF (INTOUT.NE.0) THEN
            LFLDAT(INTOUT)=.TRUE.
         END IF
C
      ELSE IF (KODE.EQ.1) THEN
         INITIALISED =.FALSE.
C     
C     CHECK THAT READING TERMINATED CORRECTLY
C     
C     
C     CHECK FOR EOF INSIDE FIXED FORMAT DATA-BODY...
C     
         IF (LINE.NE.-1) THEN
            IF (CODHDR(LINE).GT.0 .AND. CNT.NE.CODHDR(LINE)) THEN
               WRITE(*,*) MYNAME,
     &              'End of file interrupts data body.'
               IRC=345
               RETURN
            END IF
         END IF
C     
C     CHECK FOR NESTING ERROR IN IF-EXPRESSIONS...
C     
         IF (IFLVL.NE.0) THEN
            WRITE(*,*) MYNAME,
     &           'End of file interrupts if test.'
            IRC=345
            RETURN
         END IF
C     
C     CHECK FOR MISSING HEADERS...
C     
         CALL ANALFL(NRHDR,MAXHDR,HDR100,
     &        ACTHDR,LFLDAT,NRLEN,
     &        MAXGRP,NRGRP,HDRGRP,
     &        IRC)
         IF (IRC.NE.0) THEN
            WRITE(*,*) MYNAME,'Error return from ANALFL.',
     &           IRC
            RETURN
         END IF
C     
      END IF
C
      IF (BDEB) WRITE(*,*) MYNAME,'Debug: Routine ends.',IRC
C
      RETURN
      END
#__mcat: nuketail.F     **DO NOT DELETE
      CHARACTER*100 FUNCTION NUKETAIL(STRING,N)
C     ***********************************************************************
C     +                                                                     *
C     FUNCTION RETURNS THE LAST ITEM IN STRING,                             *
C     AND REMOVES IT FROM STRING                                            *
C     +                                                                     *
CIO   STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    N (I*4) = LENGTH OF STRING                                            *
CO    NUKETAIL (C*100) = TAIL OF STRING                                     *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N
      CHARACTER*1 STRING(N),C1
C
      CHARACTER*100 OUT
      INTEGER*4 CRR,II,JJ
      LOGICAL*4 BLNK,FIRST
      DATA FIRST /.TRUE./
      CHARACTER*8 MYNAME
      DATA MYNAME /'NUKETAIL'/
C
      IF (FIRST) THEN
         C1=CHAR(0)
         FIRST=.FALSE.
      ENDIF
C
      BLNK=.FALSE.
C
      CRR=N+1
C
      DO WHILE (.NOT.BLNK .AND. CRR.GT.1)
         CRR = CRR-1
         BLNK= (STRING(CRR) .EQ. ' ')
      ENDDO
C
      CALL RESET(OUT,100)
      IF (BLNK) THEN
C     SEVERAL ITEMS IN STRING
         JJ=MIN(100,N-CRR)
         DO II=1,JJ
            OUT(II:II)=STRING(II+CRR)
         ENDDO
         DO II=CRR,N
            STRING(II)=C1
         ENDDO
      ELSE
C     JUST ONE ITEM IN STRING
         JJ=MIN(100,N)
         DO II=1,JJ
            OUT(II:II)=STRING(II)
         ENDDO
         DO II=1,N
            STRING(II)=C1
         ENDDO
      ENDIF
C
      CALL CHOP(OUT,100)
      CALL CHOP(STRING,N)
C
      NUKETAIL=OUT
      RETURN
      END
#__mcat: object.F     **DO NOT DELETE
      SUBROUTINE OBJECT(STRING,N,START,POS,CODE)
C     ***********************************************************************
C     +                                                                     *
C     IDENTIFIES AN OBJECT (VARIABLE, OPERAND, NUMBER), AND RETURNS LOCATION*
C     +                                                                     *
CI    STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    N (I*4) = LENGTH OF STRING                                            *
CI    START (I*4) = POSITION AT WHICH TO START SEARCH                       *
CO    POS(2) (I*4) = START AND END POSITION OF OBJECT                       *
CO    CODE (I*4) = OBJECT TYPE IDENTIFIER                                   *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N
      CHARACTER*1 STRING(N),CHAR
      INTEGER*4 START,POS(2),CODE,ICODE
C
      CHARACTER*8 MYNAME
      DATA MYNAME /'OBJECT'/
C
      INTEGER*4 LENS,LENGTH,LEVEL,OLEVEL,JJ,CODE2,PAR,CPOS
      LOGICAL*4 FOBJ,OFOBJ,QREAL,OQREAL,DIGIT,DEFNTNR,NEED
      EXTERNAL LENGTH,DIGIT,DEFNTNR
C
      CPOS=0
      IF (CODE.EQ.1) THEN
C
C------SEARCH FORWARDS
C
         CODE2=1
         POS(1)=START
         PAR=0
C
C------IF WE PREVIOUS CHAR WAS A SIGN, SHIFT POS
C
         IF (START.GT.1) THEN
            CALL WHICH(STRING(START-1),ICODE)
            IF (ICODE.EQ.5.OR.ICODE.EQ.6) THEN
               POS(1)=START-1
            ENDIF
         ENDIF
C
C------IF WE ARE CURRENTLY AT A SIGN, MOVE FORWARDS
C
         IF (START.LT.N .AND. POS(1).EQ.START) THEN
            CALL WHICH(STRING(START),ICODE)
            IF(ICODE.EQ.5.OR.ICODE.EQ.6) START=START+1
         ENDIF
C
         LEVEL=0
         OLEVEL=0
         POS(2)=START
         JJ=START
         OQREAL=.TRUE.
         OFOBJ=.FALSE.
         FOBJ=.FALSE.
C
         LENS=LENGTH(STRING,N,LENS)
         QREAL=(LENS.GT.0)
         IF (JJ.LE.N.AND.JJ.GE.1) THEN
            CHAR=STRING(JJ)
            CALL WHICH(CHAR,ICODE)
         ELSE
            ICODE=1
         ENDIF
         IF (ICODE.EQ.0) THEN
            DO WHILE (JJ.LE.LENS .AND.
     &           .NOT.FOBJ .AND. LEVEL.GE.0)
C
               IF (STRING(JJ).EQ.'(') LEVEL=LEVEL+1
               IF (STRING(JJ).EQ.')') LEVEL=LEVEL-1
               IF (STRING(JJ).EQ.'[') LEVEL=LEVEL+1
               IF (STRING(JJ).EQ.']') LEVEL=LEVEL-1
               IF (STRING(JJ).EQ.'{') LEVEL=LEVEL+1
               IF (STRING(JJ).EQ.'}') LEVEL=LEVEL-1
C
               IF (LEVEL.EQ.1 .AND. JJ.EQ.START) THEN
                  PAR=LEVEL
                  POS(1)=POS(1)+1
               ENDIF
C
               IF (LEVEL.EQ.0) THEN
                  IF (JJ.LE.N.AND.JJ.GE.1) THEN
                     CHAR=STRING(JJ)
                     CALL WHICH(CHAR,ICODE)
                     FOBJ=(ICODE.NE.0)
                  ELSE
                     FOBJ=.FALSE.
                  ENDIF
                  IF (OQREAL) QREAL=DEFNTNR(STRING(JJ),CODE2,NEED)
                  IF (FOBJ.AND.OQREAL.AND.QREAL) FOBJ=.FALSE.
                  IF (.NOT.FOBJ) CPOS=JJ
                  IF (OLEVEL.NE.0) FOBJ=.TRUE.
                  OQREAL=QREAL
               ELSEIF(LEVEL.GT.0.AND.OLEVEL.EQ.0.AND.PAR.EQ.0) THEN
                  FOBJ=.TRUE.
               ELSEIF(LEVEL.GT.0) THEN
                  CODE2=+1
                  QREAL=.FALSE.
                  NEED=.FALSE.
                  FOBJ=.FALSE.
               ELSE
                  FOBJ=.TRUE.
               ENDIF
C
               IF (.NOT. FOBJ) THEN
                  IF (LEVEL.EQ.PAR) POS(2)=JJ
                  CPOS=JJ
                  OLEVEL=LEVEL
                  IF (OQREAL) OQREAL=QREAL
                  JJ=JJ+1
               ENDIF
C
            ENDDO
         ELSE
            CODE=ICODE
         ENDIF
      ELSEIF(CODE.EQ.-1) THEN
C
C-----SEARCH BACKWARDS
C
         CODE2=-1
         LEVEL=0
         OLEVEL=0
         POS(1)=START+1
         POS(2)=START
         JJ=START
         OQREAL=.TRUE.
         OFOBJ=.FALSE.
         FOBJ=.FALSE.
         PAR=0
C
         LENS=LENGTH(STRING,N,LENS)
         QREAL=(LENS.GT.0)
         IF (JJ.LE.N.AND.JJ.GE.1) THEN
            CHAR=STRING(JJ)
            CALL WHICH(CHAR,ICODE)
         ELSE
            ICODE=1
         ENDIF
         IF (ICODE.EQ.0) THEN
            DO WHILE (JJ.GE.1 .AND.
     &           .NOT.FOBJ .AND. LEVEL.LE.0)
C
               IF (STRING(JJ).EQ.'(') LEVEL=LEVEL+1
               IF (STRING(JJ).EQ.')') LEVEL=LEVEL-1
               IF (STRING(JJ).EQ.'[') LEVEL=LEVEL+1
               IF (STRING(JJ).EQ.']') LEVEL=LEVEL-1
               IF (STRING(JJ).EQ.'{') LEVEL=LEVEL+1
               IF (STRING(JJ).EQ.'}') LEVEL=LEVEL-1
C
               IF (LEVEL.EQ.-1 .AND. JJ.EQ.START) THEN
                  PAR=LEVEL
                  POS(2)=POS(2)-1
               ENDIF
C
               IF (LEVEL.EQ.0) THEN
                  IF (JJ.LE.N.AND.JJ.GE.1) THEN
                     CHAR=STRING(JJ)
                     CALL WHICH(CHAR,ICODE)
                     FOBJ=(ICODE.NE.0)
                  ELSE
                     FOBJ=.FALSE.
                  ENDIF
                  IF (OQREAL) QREAL=DEFNTNR(STRING(JJ),CODE2,NEED)
                  IF (FOBJ.AND.OQREAL.AND.QREAL)FOBJ=.FALSE.
                  IF (.NOT.FOBJ) CPOS=JJ
                  IF (OLEVEL.NE.0) FOBJ=.TRUE.
                  OQREAL=QREAL
               ELSEIF(LEVEL.LT.0.AND.OLEVEL.EQ.0.AND.PAR.EQ.0) THEN
                  FOBJ=.TRUE.
               ELSEIF(LEVEL.LT.0) THEN
                  CODE2=-1
                  QREAL=.FALSE.
                  NEED=.FALSE.
                  FOBJ=.FALSE.
               ELSE
                  FOBJ=.TRUE.
               ENDIF
C
               IF (.NOT. FOBJ) THEN
                  IF (LEVEL.EQ.PAR) POS(1)=JJ
                  CPOS=JJ
                  OLEVEL=LEVEL
                  IF (OQREAL) OQREAL=QREAL
                  JJ=JJ-1
               ENDIF
C
            ENDDO
C
C------IF WE PREVIOUS CHAR WAS A SIGN, SHIFT POS
C
            IF (CPOS.GT.1.AND.
     &           STRING(CPOS).NE.'-'.AND.STRING(CPOS).NE.'+') THEN
               CALL WHICH(STRING(CPOS-1),ICODE)
               IF (ICODE.EQ.5.OR.ICODE.EQ.6) THEN
                  CPOS=CPOS-1
               ENDIF
            ENDIF
         ELSE
            CODE=ICODE
         ENDIF
      ELSE
         WRITE(*,*) MYNAME,'WRONG CODE',CODE
      ENDIF
C
      START=CPOS
      IF (CPOS.GE.1 .AND. CPOS.LE.N) THEN
         CODE=0
      ELSE
         CODE=ICODE
      ENDIF
C
      IF (CODE.EQ.0) THEN
C     CHECK IF OBJECT IS SURROUNDED BY PARANTHESIS
         IF (STRING(POS(1)).EQ.'(') POS(1)=POS(1)+1
         IF (STRING(POS(2)).EQ.')') POS(2)=POS(2)-1
      ENDIF
C
      RETURN
      END
#__mcat: ord1bid.F     **DO NOT DELETE
       integer*4 function ord1bid(saf100,l1bscnum,jdate)
C+
CNOM/NAME  ord1bid.F version 1.1 on 2/12/98
C
CBUT/PURPOSE
C       delivers the order satellite number for a given
C       level 1b id number (PACS number) and a julian date.
C
CDESCRIPTION
C     FORTRAN 77 witth UKMO/METEO-FRANCE accepted extensions
C       The function searches in the array avh_sc_num the element which
C       has the same value as the input argument. A date is given to
C       avoid the conflicts between satellites
C
C       the function returns 0 if the satellite is not found or
C       if an error occur
C
C
CPROPRIETAIRE/OWNER
C       M. Derrien
C
CHISTORIQUE/HISTORY (MODIFICATIONS/CHANGES)
C(version   date      comment           <author>)
C 1.0     13/02/95   initial            M. Derrien
C
C
CFUNCTIONS AND SUBROUTINES CALLS  (RETURN CODES FOR FUNCTIONS)
C
C
CCOPYRIGHT (c) Meteo-France (EVOLUNIX - ATOVS - EUMETSAT project <1994>)
C
      implicit none
      save
C
CARGUMENTS
       integer*4 l1bscnum !  satellite id read from a 1B file
       integer*4 jdate     ! julian date of the data set
C
CDECLARATIONS
C
C identification variable for "what"
      character*62 sccsid
C
      data sccsid
     &/'@(#) ord1bid.F version 1.1 on 2/12/98'/
C
C Common declarations:
       integer*4 maxsatid
       parameter (maxsatid=15)
       integer*4 noa_sc_num(maxsatid)       ! noaa number
       integer*4 l1b_sc_num(maxsatid)       ! level 1b number (PACS)
       integer*4 avh_sc_num(maxsatid)       ! avhrr telemetry number
       integer*4 tip_sc_num(2,maxsatid)     ! tip telemetry number
       integer*4 sc_date_range(2,maxsatid)  ! operational date range
       character*8 launch_name(maxsatid)  ! pre-launch name
       character*9 sc_int_des(maxsatid)   ! s/c international designation
       character*8 noaa_name(maxsatid)    ! noaa name (noaaxx)
       character*8 alias1(maxsatid)       ! first alias of noaa name (noaax)
       character*8 alias2(maxsatid)       ! second alias of noaa name (noaa-xx)
       character*8 alias3(maxsatid)       ! third alias of noaa name (noaa-x)
       character*100 saf100
C
       common/c_satid/noa_sc_num, l1b_sc_num, avh_sc_num,
     &                 tip_sc_num, sc_date_range, launch_name,
     &                 sc_int_des, noaa_name, alias1, alias2, alias3
C
C Local variables:
       integer*4 ierr         ! rdnoaaid return code =0 OK  else I/O error
       integer*4 isat         ! loop satellite order number
       logical*4 first
       data first /.true./
C
C-
C
C       checks if it is the first calling sequence and then
C       call the file reading routine
       ierr = 0
       if(first) then
         call rdnoaaid(saf100,ierr)
         first = .false.
       endif
C
C       checks the return code
       if(ierr.eq.0) then
C
C         search the argument value in the common array for the
C         right avhrr telem number in the good range of dates.
         isat=1
          do while ( (l1b_sc_num(isat).ne.l1bscnum  .or.
     &                jdate.lt.sc_date_range(1,isat) .or.
     &                jdate.gt.sc_date_range(2,isat) ).and.
     &                           isat.le.maxsatid )
           isat=isat+1
         end do
C
C         the satellite id is found
         if(isat.le.maxsatid) then
           ord1bid = isat
         else
C           the satellite id is not present in the array
           ord1bid = 0
         endif
C
       else
C         an error occured during the file reading
         ord1bid = 0
       endif
C
       return
       end
#__mcat: perff.F     **DO NOT DELETE
      SUBROUTINE PERFF(STRING,N,CHANGED,IRC)
C     ***********************************************************************
C     +                                                                     *
C     PERFORMS MATHEMATICAL OPERATIONS ON STRING                            *
C     +                                                                     *
CIO   STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    N (I*4) = LENGTH OF STRING                                            *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N,IRC
      CHARACTER*1 STRING(N),DEL(2)
      LOGICAL*4 CHANGED
C
      INTEGER*4 LEV,POS(2),LENS,LENGTH
      EXTERNAL LENGTH
      LOGICAL*4 DONE
C
      DONE=.FALSE.
      DO WHILE (.NOT. DONE)
C
         LEV=-1
         DEL(1)='('
         DEL(2)=')'
         LENS=LENGTH(STRING,N,LENS)
         POS(1)=1
         POS(2)=LENS
         CALL ITEM(STRING,LENS,DEL,LEV,POS,IRC)
         IF (IRC.EQ.0) THEN
            IF (LEV.EQ.-1) THEN
C     NO PARANTHESIS
               DONE=.TRUE.
               POS(1)=0
               POS(2)=N+1
               CALL EXECF(STRING,N,CHANGED,POS)
            ELSE
C     EXECUTE CALC, AND REPLACE PARANTHESIS WITH []
               STRING(POS(1))='['
               STRING(POS(2))=']'
               CALL EXECF(STRING,N,CHANGED,POS)
            ENDIF
         ELSE
            DONE=.TRUE.
         ENDIF
      ENDDO
C
      IRC=0
C
      RETURN
      END
#__mcat: perfl.F     **DO NOT DELETE
      SUBROUTINE PERFL(STRING,N,CHANGED,IRC)
C     ***********************************************************************
C     +                                                                     *
C     PERFORMS LOGICAL OPERATIONS ON STRING (AND, OR, NOT ETC.)
C     +                                                                     *
CIO   STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    N (I*4) = LENGTH OF STRING                                            *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N,IRC
      CHARACTER*1 STRING(N),DEL(2)
      LOGICAL*4 CHANGED
C
      INTEGER*4 LEV,POS(2),LENS,LENGTH
      EXTERNAL LENGTH
      LOGICAL*4 DONE
C
      DONE=.FALSE.
      DO WHILE (.NOT. DONE)
C
         LEV=-1
         DEL(1)='('
         DEL(2)=')'
         LENS=LENGTH(STRING,N,LENS)
         POS(1)=1
         POS(2)=LENS
         CALL ITEM(STRING,LENS,DEL,LEV,POS,IRC)
         IF (IRC.EQ.0) THEN
            IF (LEV.EQ.-1) THEN
C     NO PARANTHESIS
               DONE=.TRUE.
               POS(1)=0
               POS(2)=N+1
               CALL EXECL(STRING,N,CHANGED,POS)
            ELSE
C     EXECUTE CALC, AND REPLACE PARANTHESIS WITH []
               STRING(POS(1))='['
               STRING(POS(2))=']'
               CALL EXECL(STRING,N,CHANGED,POS)
            ENDIF
         ELSE
            DONE=.TRUE.
         ENDIF
      ENDDO
C
      IRC=0
C
      RETURN
      END
#__mcat: perfm.F     **DO NOT DELETE
      SUBROUTINE PERFM(STRING,N,CHANGED,IRC)
C     ***********************************************************************
C     +                                                                     *
C     PERFORMS MATHEMATICAL OPERATIONS ON STRING                            *
C     +                                                                     *
CIO   STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    N (I*4) = LENGTH OF STRING                                            *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N,IRC
      CHARACTER*1 STRING(N),DEL(2)
      LOGICAL*4 CHANGED
C
      INTEGER*4 LEV,POS(2),LENS,LENGTH
      EXTERNAL LENGTH
      LOGICAL*4 DONE
C
      DONE=.FALSE.
      DO WHILE (.NOT. DONE)
C
         LEV=-1
         DEL(1)='('
         DEL(2)=')'
         LENS=LENGTH(STRING,N,LENS)
         POS(1)=1
         POS(2)=LENS
         CALL ITEM(STRING,LENS,DEL,LEV,POS,IRC)
         IF (IRC.EQ.0) THEN
            IF (LEV.EQ.-1) THEN
C     NO PARANTHESIS
               DONE=.TRUE.
               POS(1)=0
               POS(2)=N+1
               CALL EXECM(STRING,N,CHANGED,POS)
            ELSE
C     EXECUTE CALC, AND REPLACE PARANTHESIS WITH []
               STRING(POS(1))='['
               STRING(POS(2))=']'
               CALL EXECM(STRING,N,CHANGED,POS)
            ENDIF
         ELSE
            DONE=.TRUE.
         ENDIF
      ENDDO
C
      IRC=0
C
      RETURN
      END
#__mcat: qbdy.F     **DO NOT DELETE
      subroutine QBDY(MAXUNIT,FILES,LUNIT,CUNIT,
     &              MAXHDR,HDR100,NRLEN,PPDAT,INTOUT,
     &              CNT,CODHDR,LINE,DAT100,
     &              MAXVAR,NRVAR,NAMVAR,VALVAR,VARLEN,
     &              BUFF1000,LENB,PROCESS,BDONE,IRC)
C
      implicit none
      save
C
      INTEGER*4 MAXUNIT
      CHARACTER*100 FILES(MAXUNIT)
      INTEGER*4 UNITA(MAXUNIT),LUNIT(MAXUNIT),CUNIT
      INTEGER*4 MAXHDR,NROPT
      CHARACTER*100 HDR100(MAXHDR)
      PARAMETER (NROPT=5)
      LOGICAL*4 PPDAT(NROPT,MAXHDR)
      INTEGER*4 INTOUT, CNT,CODHDR(MAXHDR),LINE
      CHARACTER*100 DAT100
      INTEGER*4 MAXHDR,NRLEN(MAXHDR),MAXVAR,NRVAR
      CHARACTER*100 NAMVAR(MAXVAR),VALVAR(MAXVAR)
      INTEGER*4 VARLEN(MAXVAR)
      CHARACTER*1000 BUFF1000
      INTEGER*4 LENB
      LOGICAL*4 PROCESS, BDONE
      INTEGER*4 IRC
C
      CHARACTER*8 MYNAME
      DATA MYNAME /'QBDY'/
      INTEGER*4 LENGTH,LENF,LEND
      EXTERNAL LENGTH
      CHARACTER*1000 DUMP
      LOGICAL*4 ERROR
      DATA ERROR/.FALSE./
C
C     PRE-PROCESS LINE IF THIS IS REQUIRED
C
      IF (LINE.NE.-1) THEN
         PROCESS=.FALSE.
         CALL EVAL(BUFF1000,1000,NRVAR,NAMVAR,VALVAR,VARLEN,
     &        PPDAT(1,LINE),IRC)
         LENB=LENGTH(BUFF1000,1000,LENB)
C     
         IF (LENB.EQ.0) THEN
C     DATA LINE IS EMPTY
            WRITE(*,*) MYNAME,
     &           'Warning: empty data line found under: '//
     &           HDR100(LINE)(1:NRLEN(LINE))
         ELSE
C     
C     STORE DATA LINE
C     
            BDONE=.TRUE.
C     
            INTOUT=LINE
            DAT100=BUFF1000(1:100)
C     
            CNT=CNT+1
C     
C     CHECK IF WE ARE ACCUMULATING TOO MANY LINES
C
            IF (CODHDR(LINE).NE.-1 .AND. 
     &           CNT.GT.CODHDR(LINE)) THEN
               ERROR=.TRUE.
               BUFF1000='Too many data lines.'
            END IF
C
         ENDIF
      ENDIF
C
      IF (ERROR) THEN
         CALL CHOP(FILES(CUNIT),100)
         LENF=LENGTH(FILES(CUNIT),100,10)
         CALL CHOP(BUFF1000,100)
         LENB=LENGTH(BUFF1000,100,10)
         IF (LENF.GT.80)LENF=80
         WRITE(DUMP,*) 
     &        '"'//FILES(CUNIT)(1:LENF)//'", line ',
     &        LUNIT(CUNIT),': Error: '//BUFF1000(1:LENB)
         CALL CHOP(DUMP,200)
         LEND=LENGTH(DUMP,200,20)
         WRITE(*,*) DUMP(1:LEND)
         IRC=291
         RETURN
      ENDIF
C
      RETURN
      END
#__mcat: qcom.F     **DO NOT DELETE
      subroutine QCOM(MAXCOM,NRCOM,COM20,HLP20,CMLEN,PPDAT,
     &     MAXUNIT,UNITA,FILES,LUNIT,CUNIT,
     &     MAXHDR,NRHDR,HDR100,ACTHDR,NRLEN,
     &     MAXVAR,NRVAR,NAMVAR,VALVAR,VARLEN,IFLVL,
     &     BUFF1000,LENB,PROCESS,BDONE,ENDOFF,IRC)
C     
      implicit none
      save
C     
      INTEGER*4 MAXCOM,NRCOM
      CHARACTER*20 COM20(MAXCOM),HLP20(MAXCOM)
      INTEGER*4 CMLEN(MAXCOM),MAXUNIT
      INTEGER*4 NROPT
      PARAMETER (NROPT=5)
      LOGICAL*4 PPDAT(NROPT,NRHDR)
      INTEGER*4 UNITA(MAXUNIT),CUNIT,LUNIT(MAXUNIT)
      CHARACTER*100 FILES(MAXUNIT)
      INTEGER*4 MAXHDR,NRHDR
      CHARACTER*100 HDR100(MAXHDR)
      LOGICAL*4 ACTHDR(MAXHDR)
      INTEGER*4 NRLEN(MAXHDR),MAXVAR,NRVAR
      CHARACTER*100 NAMVAR(MAXVAR),VALVAR(MAXVAR)
      INTEGER*4 VARLEN(MAXVAR)
      CHARACTER*1000 BUFF1000
      INTEGER*4 LENB
      LOGICAL*4 PROCESS, BDONE, ENDOFF
      INTEGER*4 IRC
C     
      INTEGER*4 LENGTH,LEN2,LEN3,LENF,LENS,LENH,LEND,
     &     COMMAND,CVAR,system,IRC2
      CHARACTER*1000 STR2, STR3, DUMP, PATHF
      LOGICAL*4 BBDONE,ERROR,GO,IFACT(10),IFDON(10),IFVAL,
     &     FOUND, COMP, ACTIVE
      DATA ACTIVE /.TRUE./
      DATA ERROR/.FALSE./
      CHARACTER*100 NUKEHEAD, JNK100
      EXTERNAL NUKEHEAD, LENGTH, system
      CHARACTER*1 DEL(2),C1
      INTEGER*4 POS(2),II,JJ,KK,LEV,IFLVL
      CHARACTER*8 MYNAME
      DATA MYNAME /'QCOM'/
C
C     EQUAL SIGN IDENTIFIERS
C
      INTEGER*4 MAXEQN
      PARAMETER (MAXEQN=100)
      INTEGER*4 POSEQN(MAXEQN),CEQN
C     
C--------CHECK IF THE LINE STARTS WITH A COMMAND
C     
      C1=CHAR(0)
      COMMAND=0
      JJ=1
      FOUND=.FALSE.
      DO WHILE(.NOT.FOUND .AND. JJ.LE.MAXCOM)
         FOUND=(CMLEN(JJ).LE.LENB)
         KK=1
         DO WHILE(KK.LE.CMLEN(JJ).AND.FOUND)
            IF(FOUND) FOUND=(BUFF1000(KK:KK).EQ.COM20(JJ)(KK:KK))
            KK=KK+1
         ENDDO
         IF (FOUND)THEN
            COMMAND=JJ
         ELSE
            JJ=JJ+1
         ENDIF
      ENDDO
C     
C--------PERFORM COMMAND (IF LINE STARTS WITH IT)
C     
      IF (COMMAND.NE.0) THEN
C
         IF (COMMAND.EQ.1) THEN ! if command
            PROCESS=.FALSE.
            DEL(1)='('
            DEL(2)=')'
            LEV=0
            POS(1)=1
            POS(2)=1000
            CALL ITEM(BUFF1000,1000,DEL,LEV,POS,IRC)
            CALL RESET(STR2,1000)
            STR2=BUFF1000(1:POS(1)-1)
            CALL CHOP(STR2,1000)
            LEN2=LENGTH(STR2,1000,LENB)
            IF (IRC.NE.0.OR.LEV.EQ.-1) THEN
C     SYNTAX ERROR
               ERROR=.TRUE.
               BUFF1000='missing () in if statement.'
            ELSEIF (COM20(1)(1:CMLEN(1)).EQ.STR2(1:LEN2).AND.
     &              LENB.EQ.POS(2)) THEN
C     ANALYZE TEST VALUE
               IF ((POS(2)-POS(1)).LE.1) THEN
                  IFVAL=.TRUE.
               ELSE
                  CALL RESET(STR3,1000)
                  STR3=BUFF1000(POS(1)+1:POS(2)-1)
                  CALL EVAL(STR3,1000,NRVAR,NAMVAR,
     &                 VALVAR,VARLEN,PPDAT(1,1),IRC)
                  CALL CHOP(STR3,1000)
                  LEN3=LENGTH(STR3,1000,1)
                  IFVAL=(STR3(1:LEN3).EQ.'T')
               ENDIF
C     
               IFLVL=IFLVL+1
C     
               IF (IFVAL) THEN
                  IFACT(IFLVL)=.TRUE.
                  IFDON(IFLVL)=.TRUE.
               ELSE
                  IFACT(IFLVL)=.FALSE.
                  IFDON(IFLVL)=.FALSE.
               ENDIF
C     
            ELSE
C     SYNTAX ERROR
               ERROR=.TRUE.
               BUFF1000='strange if statement.'
            ENDIF
         ELSEIF (COMMAND.EQ.2 .AND. IFLVL.GT.0) THEN ! elseif command
            PROCESS=.FALSE.
            IF (.NOT.IFDON(IFLVL)) THEN
               DEL(1)='('
               DEL(2)=')'
               LEV=0
               POS(1)=1
               POS(2)=1000
               CALL ITEM(BUFF1000,1000,DEL,LEV,POS,IRC)
               CALL RESET(STR2,1000)
               STR2=BUFF1000(1:POS(1)-1)
               CALL CHOP(STR2,1000)
               LEN2=LENGTH(STR2,1000,LEN2)
               IF (IRC.NE.0.OR.LEV.EQ.-1) THEN
C     SYNTAX ERROR
                  ERROR=.TRUE.
                  BUFF1000='missing () in elseif statement.'
               ELSEIF (COM20(1)(1:CMLEN(1))
     &                 .EQ.STR2(1:LEN2).AND.
     &                 LENB.EQ.POS(2)) THEN
C     ANALYZE TEST VALUE
                  IF ((POS(2)-POS(1)).LE.1) THEN
                     IFVAL=.TRUE.
                  ELSE
                     CALL RESET(STR3,1000)
                     STR3=BUFF1000(POS(1)+1:POS(2)-1)
                     CALL EVAL(STR3,1000,NRVAR,NAMVAR,
     &                    VALVAR,VARLEN,PPDAT(1,1),IRC)
                     CALL CHOP(STR3,1000)
                     LEN3=LENGTH(STR3,1000,1)
                     IFVAL=(STR3(1:LEN3).EQ.'T')
                  ENDIF
C     
                  IF (IFVAL) THEN
                     IFACT(IFLVL)=.TRUE.
                     IFDON(IFLVL)=.TRUE.
                  ELSE
                     IFACT(IFLVL)=.FALSE.
                     IFDON(IFLVL)=.FALSE.
                  ENDIF
C     
               ELSE
                  ERROR=.TRUE.
                  BUFF1000='strange elseif statement.'
               ENDIF
            ELSE
               IFACT(IFLVL)=.FALSE.
            ENDIF
         ELSEIF (COMMAND.EQ.3 .AND. IFLVL.GT.0) THEN ! else command
            PROCESS=.FALSE.
            IF (.NOT.IFDON(IFLVL)) THEN
               IFACT(IFLVL)=.TRUE.
               IFDON(IFLVL)=.TRUE.
            ELSE
               IFACT(IFLVL)=.FALSE.
            ENDIF
         ELSEIF (COMMAND.EQ.4 .AND. IFLVL.GT.0) THEN  ! endif command
            PROCESS=.FALSE.
            IFACT(IFLVL)=.FALSE.
            IFDON(IFLVL)=.FALSE.
            IFLVL=IFLVL-1
         ENDIF
C     
C     MAKE SURE WE REIGSTER NESTING ERRORS
C     
         IF (PROCESS .AND. COMMAND.LE.4) THEN
            ERROR=.TRUE.
            BUFF1000='elseif, else or endif out of place.'
         ENDIF
C     
C     COMMANDS ONLY CHECKED IF WE ARE IN AN ACTIVE REGION
C     
         IF (IFLVL.NE.0) THEN
            ACTIVE=(IFACT(IFLVL))
         ELSE
            ACTIVE=.TRUE.
         END IF
         IF (PROCESS .AND. .NOT.ACTIVE) PROCESS = .FALSE.
C     
C     EVALUATE EXPRESSIONS (IN CASE OF ECHO OR INCLUDE)...
C     
         IF (PROCESS) THEN
            CALL EVAL(BUFF1000,1000,NRVAR,NAMVAR,
     &           VALVAR,VARLEN,PPDAT(1,1),IRC)
            IF (IRC.NE.0) THEN
               WRITE(*,*) MYNAME,'Error return from EVAL',IRC
               RETURN
            ENDIF
            LENB=LENGTH(BUFF1000,1000,LENB)
         ENDIF
C
         IF (COMMAND.EQ.5 .AND. PROCESS) THEN ! execute unix command
            PROCESS=.FALSE.
            IRC=system(BUFF1000(2:LENB))
            IF (IRC.NE.0) THEN
               BUFF1000='Error in UNIX command.'
               ERROR = .TRUE.
            ENDIF
         ELSEIF (COMMAND.EQ.6.AND.PROCESS) THEN ! include file
            PROCESS=.FALSE.
            DEL(1)='('
            DEL(2)=')'
            LEV=0
            POS(1)=1
            POS(2)=LENB
            CALL ITEM(BUFF1000,LENB,DEL,LEV,POS,IRC)
            IF (IRC.NE.0.OR.LEV.EQ.-1) THEN  ! syntax error
               ERROR=.TRUE.
               BUFF1000='missing () in include statement.'
            ELSE
               PATHF=BUFF1000(POS(1)+1:POS(2)-1)
               CALL CHOP(PATHF,LENB)
               LENF=LENGTH(PATHF,100,10)
               IF (CUNIT.LT.MAXUNIT) THEN
                  CUNIT=CUNIT+1
                  FILES(CUNIT)=PATHF(1:LENF)
               ELSE
                  ERROR=.TRUE.
                  BUFF1000='too deep file structure: '//
     &                 PATHF(1:LENF)
               ENDIF
            ENDIF
         ELSEIF (COMMAND.EQ.7.AND.PROCESS) THEN ! stop command
            PROCESS=.FALSE.
            BDONE=.TRUE.
            ENDOFF=.TRUE.
         ELSEIF (COMMAND.EQ.8.AND.PROCESS) THEN ! exit command
            PROCESS=.FALSE.
            JNK100=NUKEHEAD(BUFF1000,100)
            LENB=LENGTH(BUFF1000,1000,2)
            IF (LENB.NE.0) THEN
               READ(BUFF1000(1:LENB),*,IOSTAT=IRC2) IRC
               IF (IRC2.NE.0) THEN
                  BUFF1000='Unable to read return code.'
                  ERROR=.TRUE.
               ELSE
                  CALL exit(IRC)
               END IF
            ELSE
               IRC=0
               CALL exit(IRC)
            END IF
         ELSEIF (COMMAND.EQ.9.AND.PROCESS) THEN ! write command
            PROCESS=.FALSE.
            JNK100=NUKEHEAD(BUFF1000,100)
            CALL CHOP(BUFF1000,LENB)
            LENB=LENGTH(BUFF1000,LENB,LENB)
            WRITE(*,*) BUFF1000(1:LENB)
         ELSEIF (COMMAND.EQ.10 .AND. PROCESS) THEN ! set command
            PROCESS=.FALSE.
C
C     IDENTIFY ALL EQUAL SIGNS
C
            COMP=.FALSE.
            CEQN=0
            LENB=LENGTH(BUFF1000,1000,LENB)
            DO II=1,LENB
               IF (BUFF1000(II:II).EQ.'=') THEN
                  CEQN=CEQN+1
                  POSEQN(CEQN)=II
               ENDIF
            ENDDO
C     
C     LOOP THROUGH ALL EQUATIONS
C     
            IF (CEQN.GT.0) THEN
C     FOUND AT LEAST ONE '='
               DO KK=CEQN,1,-1
C     
                  IF (KK.GT.1) THEN
                     POS(1)=POSEQN(KK-1)+1
                  ELSE
                     POS(1)=4
                  ENDIF
C     
                  IF (KK.LT.CEQN) THEN
                     POS(2)=POSEQN(KK+1)-1
                  ELSE
                     POS(2)=1000
                  ENDIF
C     
C     GET PART OF STRING BEFORE AND AFTER '='
C     
                  CALL RESET(STR2,1000)
                  STR2=BUFF1000(POS(1):POSEQN(KK)-1)
                  CALL EVAL(STR2,1000,NRVAR,NAMVAR,
     &                 VALVAR,VARLEN,PPDAT(1,1),IRC)
                  CALL CHOP(STR2,1000)
                  LEN2=LENGTH(STR2,100,LEN2)
                  CALL RESET(STR3,1000)
                  STR3=BUFF1000(POSEQN(KK)+1:POS(2))
                  CALL EVAL(STR3,1000,NRVAR,NAMVAR,
     &                 VALVAR,VARLEN,PPDAT(1,1),IRC)
                  CALL CHOP(STR3,1000)
                  LEN3=LENGTH(STR3,100,LEN3)
C     
C     FIND OUT IF VARIABLE EXISTS
C     
                  II=0
                  FOUND=.FALSE.
                  DO WHILE (II.LT.NRVAR .AND. .NOT.FOUND)
                     II=II+1
                     JJ=0
                     FOUND=(VARLEN(II).EQ.LEN2.AND.LEN2.NE.0)
                     DO WHILE (JJ.LT.LEN2 .AND. FOUND)
                        JJ=JJ+1
                        IF (FOUND) FOUND=(STR2(JJ:JJ).EQ.
     &                       NAMVAR(II)(JJ:JJ))
                     ENDDO
                  ENDDO
                  CVAR=II
C     
                  LEN3=MIN(LEN3,1)
                  IF (STR3(1:LEN3).EQ.'.'.OR.
     &                 STR3(1:LEN3).EQ.C1) THEN
                     IF (FOUND) THEN
C     REMOVE VARIABLE
                        NAMVAR(CVAR)=NAMVAR(NRVAR)
                        VALVAR(CVAR)=VALVAR(NRVAR)
                        VARLEN(CVAR)=VARLEN(NRVAR)
                        NRVAR=NRVAR-1
                     ELSE
                        ERROR=.TRUE.
                        BUFF1000='attempt to remove non-existent'//
     &                       ' variable.'
                     ENDIF
                  ELSE
C     ADD/UPDATE VARIABLE
                     IF (FOUND) THEN
                        VALVAR(CVAR)=STR3(1:100)
                     ELSE
                        IF (NRVAR.LT.MAXVAR) THEN
                           NRVAR=NRVAR+1
                           NAMVAR(NRVAR)=STR2(1:100)
                           VALVAR(NRVAR)=STR3(1:100)
                           VARLEN(NRVAR)=
     &                          LENGTH(NAMVAR(NRVAR),100,5)
                        ENDIF
                     ENDIF
                  ENDIF
               ENDDO
            ENDIF
         ELSEIF (COMMAND.EQ.11 .AND. PROCESS) THEN
            PROCESS=.FALSE.
C     IMPORT
C     FIRST REMOVE THE ACTUAL COMMAND...
            STR2=NUKEHEAD(BUFF1000,100)
C     READ THE FIRST ARGUMENT...
            STR2=NUKEHEAD(BUFF1000,100)
            CALL CHOP(STR2,1000)
            LEN2=LENGTH(STR2,100,LEN2)
            BBDONE = (LEN2.LE.0)
            DO WHILE (.NOT. BBDONE)
               CALL EVAL(STR2,1000,NRVAR,NAMVAR,
     &              VALVAR,VARLEN,PPDAT(1,1),IRC)
               CALL CHOP(STR2,1000)
               LEN2=LENGTH(STR2,100,LEN2)
               CALL RESET(STR3,1000)
C     IMPORT ENVIRONMENT VARIABLE FROM SHELL...
               call getenv(str2(1:len2),str3)
C     CALL EVAL(STR3,1000,NRVAR,NAMVAR,
C     &                    VALVAR,VARLEN,PPDAT(1,1),IRC)
               CALL CHOP(STR3,1000)
               LEN3=LENGTH(STR3,100,LEN3)
C     
C     FIND OUT IF VARIABLE EXISTS
C     
               II=0
               FOUND=.FALSE.
               DO WHILE (II.LT.NRVAR .AND. .NOT.FOUND)
                  II=II+1
                  JJ=0
                  FOUND=(VARLEN(II).EQ.LEN2.AND.LEN2.NE.0)
                  DO WHILE (JJ.LT.LEN2 .AND. FOUND)
                     JJ=JJ+1
                     IF (FOUND) FOUND=(STR2(JJ:JJ).EQ.
     &                    NAMVAR(II)(JJ:JJ))
                  ENDDO
               ENDDO
               CVAR=II
C     
               LEN3=MIN(LEN3,1)
               IF (STR3(1:LEN3).EQ.'.'.OR.
     &              STR3(1:LEN3).EQ.C1) THEN
                  IF (FOUND) THEN
C     REMOVE VARIABLE
                     NAMVAR(CVAR)=NAMVAR(NRVAR)
                     VALVAR(CVAR)=VALVAR(NRVAR)
                     VARLEN(CVAR)=VARLEN(NRVAR)
                     NRVAR=NRVAR-1
                  ELSE
                     ERROR=.TRUE.
                     BUFF1000='attempt to remove non-existent'//
     &                    ' variable.'
                  ENDIF
               ELSE
C     ADD/UPDATE VARIABLE
                  IF (FOUND) THEN
                     VALVAR(CVAR)=STR3(1:100)
                  ELSE
                     IF (NRVAR.LT.MAXVAR) THEN
                        NRVAR=NRVAR+1
                        NAMVAR(NRVAR)=STR2(1:100)
                        VALVAR(NRVAR)=STR3(1:100)
                        VARLEN(NRVAR)=
     &                       LENGTH(NAMVAR(NRVAR),100,5)
                     ENDIF
                  ENDIF
               ENDIF
C     
C     READ THE NEXT ARGUMENT...
C     
               IF (ERROR) THEN
                  BBDONE=.TRUE.
               ELSE
                  STR2=NUKEHEAD(BUFF1000,100)
                  CALL CHOP(STR2,1000)
                  LEN2=LENGTH(STR2,100,LEN2)
                  BBDONE = (LEN2.LE.0)
               END IF
            END DO
         ELSEIF (COMMAND.EQ.12 .AND. PROCESS) THEN ! help
            PROCESS=.FALSE.
C     LIST ALL HEADERS
            WRITE(*,*) MYNAME,
     &           '--------LIST OF POSSIBLE HEADERS--------'
            DO II=1,NRHDR
               LENS=LENGTH(HDR100(II),100,NRLEN(II)+3)
               IF(ACTHDR(II))
     &              WRITE(*,*) HDR100(II)(1:LENS)
            ENDDO
            WRITE(*,*) MYNAME,
     &           '--------LIST OF POSSIBLE COMMANDS-------'
            DO II=1,MAXCOM
               LENS=LENGTH(COM20(II),20,3)
               LENH=LENGTH(HLP20(II),20,3)
               WRITE(*,*) COM20(II)(1:LENS)//' '//
     &              HLP20(II)(1:LENH)
            ENDDO
            WRITE(*,*) MYNAME,
     &           '----------------------------------------'
         ENDIF
C
         IF (BDONE) PROCESS=.FALSE.
C
         IF (ERROR) THEN
            CALL CHOP(FILES(CUNIT),100)
            LENF=LENGTH(FILES(CUNIT),100,10)
            CALL CHOP(BUFF1000,100)
            LENB=LENGTH(BUFF1000,100,10)
            IF (LENF.GT.80)LENF=80
            WRITE(DUMP,*) 
     &           '"'//FILES(CUNIT)(1:LENF)//'", line ',
     &           LUNIT(CUNIT),': Error: '//BUFF1000(1:LENB)
            CALL CHOP(DUMP,200)
            LEND=LENGTH(DUMP,200,20)
            WRITE(*,*) DUMP(1:LEND)
            IRC=291
            RETURN
         ENDIF
C
      ELSE
         PROCESS=ACTIVE         ! ONLY PROCESS HEADERS IN ACTIVE REGIONS
      ENDIF
C
      RETURN
      END
#__mcat: qhdr.F     **DO NOT DELETE
      SUBROUTINE QHDR(MAXUNIT,FILES,LUNIT,CUNIT,
     &     MAXHDR,NRHDR,HDR100,ACTHDR,NRLEN,LFLDAT,
     &     INTOUT,CNT,CODHDR,LINE,
     &     BUFF1000,LENB,
     &     PROCESS,BDONE,IRC)
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 MAXUNIT,CUNIT,LUNIT(MAXUNIT)
      CHARACTER*100 FILES(MAXUNIT)
      INTEGER*4 MAXHDR,NRHDR
      CHARACTER*100 HDR100(MAXHDR)
      LOGICAL*4 ACTHDR(MAXHDR)
      INTEGER*4 NRLEN(MAXHDR)
      LOGICAL*4 LFLDAT(MAXHDR)
      INTEGER*4 INTOUT,CNT,CODHDR(MAXHDR),LINE
      CHARACTER*1000 BUFF1000
      INTEGER*4 LENB
      LOGICAL*4 PROCESS,BDONE
      INTEGER*4 IRC
C
      INTEGER*4 JJ,KK,LENF,LEND,LENGTH
      EXTERNAL LENGTH
      LOGICAL*4 FOUND,ERROR
      DATA ERROR/.FALSE./
      CHARACTER*1000 DUMP
      CHARACTER*8 MYNAME
      DATA MYNAME /'QHDR'/
C
      JJ=1
      FOUND=.FALSE.
      DO WHILE(.NOT.FOUND .AND. JJ.LE.MAXHDR)
         FOUND=((NRLEN(JJ).LE.LENB).AND.(ACTHDR(JJ)))
         KK=1
         DO WHILE(KK.LE.NRLEN(JJ).AND.FOUND)
            IF(FOUND) 
     &           FOUND=(BUFF1000(KK:KK).EQ.HDR100(JJ)(KK:KK))
            KK=KK+1
         ENDDO
         IF (FOUND)THEN
            PROCESS=.FALSE.
C     
C     CHECK IF WE ARE INTERUPTING ANOTHER DATA BODY
C     
            IF (LINE.NE.-1) THEN
               IF (CODHDR(LINE).NE.-1 .AND. 
     &              CNT.NE.CODHDR(LINE)) THEN
                  ERROR=.TRUE.
                  BUFF1000='header in data body'
               END IF
            ENDIF
C     
C     PREPARE FOR DATABODY
C     
            LINE=JJ
            CNT=0
            INTOUT=LINE
            IF (CODHDR(LINE).EQ.0) THEN
               BDONE=.TRUE.
            ENDIF
         ELSE
            JJ=JJ+1
         ENDIF
      ENDDO
C
      IF (ERROR) THEN
         CALL CHOP(FILES(CUNIT),100)
         LENF=LENGTH(FILES(CUNIT),100,10)
         CALL CHOP(BUFF1000,100)
         LENB=LENGTH(BUFF1000,100,10)
         IF (LENF.GT.80)LENF=80
         WRITE(DUMP,*) 
     &        '"'//FILES(CUNIT)(1:LENF)//'", line ',
     &        LUNIT(CUNIT),': Error: '//BUFF1000(1:LENB)
         CALL CHOP(DUMP,200)
         LEND=LENGTH(DUMP,200,20)
         WRITE(*,*) DUMP(1:LEND)
         IRC=291
         RETURN
      ENDIF
C
      RETURN
      END

#__mcat: qlfl.F     **DO NOT DELETE
      logical*4 function QLFL(MAXGRP,NRGRP,
     &     BHDRGRPA,BHDRGRPB)
C
      implicit none
      save
C
      integer*4 maxgrp, nrgrp
      integer*4 BHDRGRPA(2,maxgrp),BHDRGRPB(2,maxgrp)
C
      logical*4 later,bdone
      integer*4 ii
C
      II=1
      later=.TRUE.
      bdone=(ii.gt.nrgrp)
      DO WHILE (.not. bdone)
         if (bhdrgrpa(1,ii).EQ.bhdrgrpb(1,ii) .and.
     &        bhdrgrpa(2,ii).EQ.bhdrgrpb(2,ii)) then
            ii=ii+1
         else if (bhdrgrpa(2,ii).lt.bhdrgrpb(2,ii) .OR.
     &           (bhdrgrpa(1,ii).lt.bhdrgrpb(1,ii) .and.
     &        bhdrgrpa(2,ii).EQ.bhdrgrpb(2,ii))) then
            later=.true.
            bdone=.true.
         else
            later=.false.
            bdone=.true.
         end if
         if (.not.bdone) bdone=(ii.gt.nrgrp)
      END DO
C
      qlfl=later
      return
      end
#__mcat: reset.F     **DO NOT DELETE
      SUBROUTINE RESET(STRING,N)
C     ***********************************************************************
C     +                                                                     *
C     ERASES CONTENTS OF STRING                                             *
C     +                                                                     *
CIO   STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    N (I*4) = LENGTH OF STRING                                            *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N
      CHARACTER*(*) STRING
      CHARACTER*1 C1
      LOGICAL*4 FIRST
      DATA FIRST /.TRUE./
      INTEGER*4 II
C
      IF (FIRST) THEN
         C1=CHAR(0)
         FIRST=.FALSE.
      ENDIF
      DO II=1,N
         STRING(II:II)=C1
      ENDDO
      RETURN
      END
#__mcat: slavel.F     **DO NOT DELETE
      SUBROUTINE SLAVEL(STRING1,STRING2,STRING3,OP,CLEAN,CHANGED,IRC)
C     ***********************************************************************
C     +                                                                     *
C     EXECUTES MATHEMATICAL OPERATION 'OP' ON STRING1 AND STRING2.          *
C     THE RESULT IS RETURNED IN STRING3                                     *
C     +                                                                     *
CI    STRING1 (C*100) = FIRST ARGUMENT                                      *
CI    STRING2 (C*100) = SECOND ARGUMENT                                     *
CO    STRING3 (C*100) = RESULT                                              *
CI    OP (I*4) = OPERATION,                                                 *
C     +      =1  ==                                                         *
C     +      =2  >=                                                         *
C     +      =3  <=                                                         *
C     +      =4  <>                                                         *
C     +      =5  >                                                          *
C     +      =6  <                                                          *
C     +      =7  !                                                          *
C     +      =8  &&                                                         *
C     +      =9  ||                                                         *
CIO   CLEAN (L*4) = .TRUE. IF NO BRACKETS SHOULD BE ADDED (IF NOT EVAL)     *
CO    IRC=ERROR RETURN CODE (IRC=0 OK, IRC=1 IF NO OPERATION)               *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      CHARACTER*100 STRING1,STRING2,STRING3
      CHARACTER*100 STRB1,STRB2
      LOGICAL*4 CLEAN,CHANGED
      INTEGER*4 OP,IRC
C
      INTEGER*4 LEN1,LEN2,LEN3,LENGTH,ISI(2)
      REAL*8 ISR(2)
C
      LOGICAL*4 ISINT,ISREAL,QINT(2),QREA(2),QLOG(2),
     &     CAMEWS,PSGN(2),ATOM,ISL(2),RRL,DONE,ISLOG
      EXTERNAL LENGTH,ISINT,ISREAL,ISLOG,ATOM
C
      DATA LEN1 /1/
      DATA LEN2 /1/
C
C     INITIALIZE
C
      IRC=0
      CALL CHOP(STRING1,100)
      CALL CHOP(STRING2,100)
      CALL RESET(STRING3,100)
C
      STRB1=STRING1
      STRB2=STRING2
C
      LEN1=LENGTH(STRB1,100,LEN1)
      LEN2=LENGTH(STRB2,100,LEN2)
C
      CAMEWS=(STRB1(1:1).EQ.'-'.OR.STRB1(1:1).EQ.'+')
C
      IF (STRB1(1:1).EQ.'-') THEN
         PSGN(1)=.FALSE.
         STRB1=STRB1(2:LEN1)
         LEN1=LEN1-1
      ELSEIF (STRB1(1:1).EQ.'+') THEN
         PSGN(1)=.TRUE.
         STRB1=STRB1(2:LEN1)
         LEN1=LEN1-1
      ELSE
         PSGN(1)=.TRUE.
      ENDIF
C
      IF (STRB2(1:1).EQ.'-') THEN
         PSGN(2)=.FALSE.
         STRB2=STRB2(2:LEN2)
         LEN2=LEN2-1
      ELSEIF (STRB2(1:1).EQ.'+') THEN
         PSGN(2)=.TRUE.
         STRB2=STRB2(2:LEN2)
         LEN2=LEN2-1
      ELSE
         PSGN(2)=.TRUE.
      ENDIF
C
      IF (STRB1(1:1).EQ.'['.AND.STRB1(LEN1:LEN1).EQ.']') THEN
         IF (ATOM(STRB1(2:LEN1-1),LEN1-2)) THEN
            STRB1=STRB1(2:LEN1-1)
         ENDIF
      ENDIF
C
      IF (STRB2(1:1).EQ.'['.AND.STRB2(LEN2:LEN2).EQ.']') THEN
         IF (ATOM(STRB2(2:LEN2-1),LEN2-2)) THEN
            STRB2=STRB2(2:LEN2-1)
         ENDIF
      ENDIF
C
C     FIND OUT IF NUMBERS ARE INTEGERS OR REAL
C
      QINT(1)=ISINT(STRB1,ISI(1))
      QINT(2)=ISINT(STRB2,ISI(2))
      QREA(1)=ISREAL(STRB1,ISR(1))
      QREA(2)=ISREAL(STRB2,ISR(2))
      QLOG(1)=ISLOG(STRB1,ISL(1))
      QLOG(2)=ISLOG(STRB2,ISL(2))
C
      DONE=.FALSE.
C
      IF (QINT(1).AND.QINT(2)) THEN
         IF (OP.EQ.1) THEN
            IF (.NOT.PSGN(1)) ISI(1)=-ISI(1)
            IF (.NOT.PSGN(2)) ISI(2)=-ISI(2)
            RRL=ISI(1).EQ.ISI(2)
            DONE=.TRUE.
         ELSEIF (OP.EQ.2) THEN
            IF (.NOT.PSGN(1)) ISI(1)=-ISI(1)
            IF (.NOT.PSGN(2)) ISI(2)=-ISI(2)
            RRL=ISI(1).GE.ISI(2)
            DONE=.TRUE.
         ELSEIF (OP.EQ.3) THEN
            IF (.NOT.PSGN(1)) ISI(1)=-ISI(1)
            IF (.NOT.PSGN(2)) ISI(2)=-ISI(2)
            RRL=ISI(1).LE.ISI(2)
            DONE=.TRUE.
         ELSEIF (OP.EQ.4) THEN
            IF (.NOT.PSGN(1)) ISI(1)=-ISI(1)
            IF (.NOT.PSGN(2)) ISI(2)=-ISI(2)
            RRL=ISI(1).NE.ISI(2)
            DONE=.TRUE.
         ELSEIF (OP.EQ.5) THEN
            IF (.NOT.PSGN(1)) ISI(1)=-ISI(1)
            IF (.NOT.PSGN(2)) ISI(2)=-ISI(2)
            RRL=ISI(1).GT.ISI(2)
            DONE=.TRUE.
         ELSEIF (OP.EQ.6) THEN
            IF (.NOT.PSGN(1)) ISI(1)=-ISI(1)
            IF (.NOT.PSGN(2)) ISI(2)=-ISI(2)
            RRL=ISI(1).LT.ISI(2)
            DONE=.TRUE.
         ENDIF
      ELSEIF ((QINT(1).AND.QREA(2)).OR.
     &        (QINT(2).AND.QREA(1)).OR.
     &        (QREA(1).AND.QREA(2))) THEN
         IF (QINT(1)) ISR(1)=DFLOAT(ISI(1))
         IF (QINT(2)) ISR(2)=DFLOAT(ISI(2))
         IF (OP.EQ.1) THEN
            IF (.NOT.PSGN(1)) ISR(1)=-ISR(1)
            IF (.NOT.PSGN(2)) ISR(2)=-ISR(2)
            RRL=ISR(1).EQ.ISR(2)
            DONE=.TRUE.
         ELSEIF (OP.EQ.2) THEN
            IF (.NOT.PSGN(1)) ISR(1)=-ISR(1)
            IF (.NOT.PSGN(2)) ISR(2)=-ISR(2)
            RRL=ISR(1).GE.ISR(2)
            DONE=.TRUE.
         ELSEIF (OP.EQ.3) THEN
            IF (.NOT.PSGN(1)) ISR(1)=-ISR(1)
            IF (.NOT.PSGN(2)) ISR(2)=-ISR(2)
            RRL=ISR(1).LE.ISR(2)
            DONE=.TRUE.
         ELSEIF (OP.EQ.4) THEN
            IF (.NOT.PSGN(1)) ISR(1)=-ISR(1)
            IF (.NOT.PSGN(2)) ISR(2)=-ISR(2)
            RRL=ISR(1).NE.ISR(2)
            DONE=.TRUE.
         ELSEIF (OP.EQ.5) THEN
            IF (.NOT.PSGN(1)) ISR(1)=-ISR(1)
            IF (.NOT.PSGN(2)) ISR(2)=-ISR(2)
            RRL=ISR(1).GT.ISR(2)
            DONE=.TRUE.
         ELSEIF (OP.EQ.6) THEN
            IF (.NOT.PSGN(1)) ISR(1)=-ISR(1)
            IF (.NOT.PSGN(2)) ISR(2)=-ISR(2)
            RRL=ISR(1).LT.ISR(2)
            DONE=.TRUE.
         ENDIF
      ELSE
         IF (OP.EQ.1.AND.STRING1.EQ.STRING2) THEN
            RRL=.TRUE.
            DONE=.TRUE.
         ELSEIF (OP.EQ.2 .AND. STRING1.EQ.STRING2) THEN
            RRL=.TRUE.
            DONE=.TRUE.
         ELSEIF (OP.EQ.3 .AND. STRING1.EQ.STRING2) THEN
            RRL=.TRUE.
            DONE=.TRUE.
         ELSE
            IF  (QLOG(2) .AND.
     &           (OP.EQ.7.OR.(QLOG(1).AND.OP.GE.8))) THEN
               IF (OP.EQ.7) THEN
                  RRL=(.NOT.ISL(2))
                  DONE=.TRUE.
               ELSEIF (OP.EQ.8) THEN
                  RRL=(ISL(1).AND.ISL(2))
                  DONE=.TRUE.
               ELSEIF (OP.EQ.9) THEN
                  RRL=(ISL(1).OR.ISL(2))
                  DONE=.TRUE.
               ENDIF
            ENDIF
         ENDIF
      ENDIF
C
      IF (DONE) THEN
         CHANGED=.TRUE.
         IF (RRL) THEN
            STRING3='T'
         ELSE
            STRING3='F'
         ENDIF
         IF (CAMEWS) THEN
            IF (PSGN(1)) THEN
               STRING3='+'//STRING3(1:99)
            ELSE
               STRING3='-'//STRING3(1:99)
            ENDIF
         ENDIF
         IF (OP.EQ.7) THEN
            LEN1=LENGTH(STRING1,100,LEN1)
            STRING3=STRING1(1:LEN1)//STRING3(1:100-LEN1)
            CALL CHOP(STRING3,100)
         ENDIF
      ELSE
C
C     ADD PROTECTIVE BRACKETS...
C
         LEN1=LENGTH(STRING1,100,LEN1)
         LEN2=LENGTH(STRING2,100,LEN1)
         IF (OP.EQ.1) THEN
            STRING3=STRING1(1:LEN1)//'=='//STRING2(1:LEN2)
         ELSEIF (OP.EQ.2) THEN
            STRING3=STRING1(1:LEN1)//'>='//STRING2(1:LEN2)
         ELSEIF (OP.EQ.3) THEN
            STRING3=STRING1(1:LEN1)//'<='//STRING2(1:LEN2)
         ELSEIF (OP.EQ.4) THEN
            STRING3=STRING1(1:LEN1)//'<>'//STRING2(1:LEN2)
         ELSEIF (OP.EQ.5) THEN
            STRING3=STRING1(1:LEN1)//'>'//STRING2(1:LEN2)
         ELSEIF (OP.EQ.6) THEN
            STRING3=STRING1(1:LEN1)//'<'//STRING2(1:LEN2)
         ELSEIF (OP.EQ.7) THEN
            STRING3=STRING1(1:LEN1)//'!'//STRING2(1:LEN2)
         ELSEIF (OP.EQ.8) THEN
            STRING3=STRING1(1:LEN1)//'&&'//STRING2(1:LEN2)
         ELSEIF (OP.EQ.9) THEN
            STRING3=STRING1(1:LEN1)//'||'//STRING2(1:LEN2)
         ENDIF
C
C     NO OPERATION WAS PERFORMED
C
         IRC=105
C
         IF (.NOT.CLEAN) THEN
            CALL CHOP(STRING3,100)
            LEN3=LENGTH(STRING3,100,LEN1+LEN2+1)
            STRING3='{'//STRING3(1:LEN3)//'}'
         ENDIF
      ENDIF
      RETURN
      END
#__mcat: slavem.F     **DO NOT DELETE
      SUBROUTINE SLAVEM(STRING1,STRING2,STRING3,OP,CLEAN,CHANGED,IRC)
C     ***********************************************************************
C     +                                                                     *
C     EXECUTES MATHEMATICAL OPERATION 'OP' ON STRING1 AND STRING2.          *
C     THE RESULT IS RETURNED IN STRING3                                     *
C     +                                                                     *
CI    STRING1 (C*100) = FIRST ARGUMENT                                      *
CI    STRING2 (C*100) = SECOND ARGUMENT                                     *
CO    STRING3 (C*100) = RESULT                                              *
CI    OP (I*4) = OPERATION,                                                 *
C     +      =1  ^                                                          *
C     +      =2  *                                                          *
C     +      =3  /                                                          *
C     +      =4  +                                                          *
CIO   CLEAN (L*4) = .TRUE. IF NO BRACKETS SHOULD BE ADDED (IF NOT EVAL)     *
CO    IRC=ERROR RETURN CODE (IRC=0 OK, IRC=1 IF NO OPERATION)               *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      CHARACTER*100 STRING1,STRING2,STRING3
      CHARACTER*100 STRB1,STRB2
      LOGICAL*4 CLEAN,CHANGED
      INTEGER*4 OP,IRC
C
      INTEGER*4 LEN1,LEN2,LEN3,LENGTH,ISI(2),RRI
      REAL*8 ISR(2),RRR
C
      LOGICAL*4 ISINT,ISREAL,QINT(2),QREA(2),
     &     CAMEWS,PSGN(2),PST,ATOM,DONE, GOINT
      EXTERNAL LENGTH,ISINT,ISREAL,ATOM
C
      DATA LEN1 /1/
      DATA LEN2 /1/
C
      CHARACTER*8 MYNAME
      DATA MYNAME /'SLAVEM'/
C
      LOGICAL*4 ACTIVE,BDEB
      DATA ACTIVE /.FALSE./
C
      IF (.NOT.ACTIVE) CALL DEBUG(MYNAME,BDEB,ACTIVE)
C
      IF (BDEB) WRITE(*,*) MYNAME,'Debug: Routine starts.',IRC
C
C     INITIALIZE
C
      IRC=0
      CALL CHOP(STRING1,100)
      CALL CHOP(STRING2,100)
      CALL RESET(STRING3,100)
C
      STRB1=STRING1
      STRB2=STRING2
C
      LEN1=LENGTH(STRB1,100,LEN1)
      LEN2=LENGTH(STRB2,100,LEN2)
C
C
      CAMEWS=(STRB1(1:1).EQ.'-'.OR.STRB1(1:1).EQ.'+')
C
      IF (STRB1(1:1).EQ.'-') THEN
         PSGN(1)=.FALSE.
         STRB1=STRB1(2:LEN1)
         LEN1=LEN1-1
      ELSEIF (STRB1(1:1).EQ.'+') THEN
         PSGN(1)=.TRUE.
         STRB1=STRB1(2:LEN1)
         LEN1=LEN1-1
      ELSE
         PSGN(1)=.TRUE.
      ENDIF
C
      IF (STRB2(1:1).EQ.'-') THEN
         PSGN(2)=.FALSE.
         STRB2=STRB2(2:LEN2)
         LEN2=LEN2-1
      ELSEIF (STRB2(1:1).EQ.'+') THEN
         PSGN(2)=.TRUE.
         STRB2=STRB2(2:LEN2)
         LEN2=LEN2-1
      ELSE
         PSGN(2)=.TRUE.
      ENDIF
C
      IF (STRB1(1:1).EQ.'['.AND.STRB1(LEN1:LEN1).EQ.']') THEN
         IF (ATOM(STRB1(2:LEN1-1),LEN1-2)) THEN
            STRB1=STRB1(2:LEN1-1)
         ENDIF
      ENDIF
C
      IF (STRB2(1:1).EQ.'['.AND.STRB2(LEN2:LEN2).EQ.']') THEN
         IF (ATOM(STRB2(2:LEN2-1),LEN2-2)) THEN
            STRB2=STRB2(2:LEN2-1)
         ENDIF
      ENDIF
C
C     FIND OUT IF NUMBERS ARE INTEGERS OR REAL
C
      QINT(1)=ISINT(STRB1,ISI(1))
      QINT(2)=ISINT(STRB2,ISI(2))
      QREA(1)=ISREAL(STRB1,ISR(1))
      QREA(2)=ISREAL(STRB2,ISR(2))
C
      DONE=.FALSE.
C
C     MAKE SURE WE DON'T RETURN AN INTEGER (0) FOR '2^(-2)'
      GOINT=(QINT(1).AND.QINT(2)) ! both numbers must be integers
      IF (GOINT) GOINT=(.NOT.OP.EQ.1) ! exponents are always treated as real
      IF (GOINT) GOINT=(OP.NE.3 .OR. (OP.EQ.3 .AND. ISI(2).NE.0)) ! we can not divide by 0
      IF (GOINT) GOINT=(OP.EQ.3.AND.MOD(ISI(1),ISI(2)).NE.0) ! check that division product is integer
      IF (GOINT) THEN
C     BOTH NUMBERS ARE INTEGERS
         IF (OP.EQ.1) THEN
            IF (.NOT.PSGN(2)) ISI(2)=-ISI(2)
            RRI=ISI(1)**ISI(2)
            IF (.NOT.PSGN(1)) RRI=-RRI
            DONE=.TRUE.
         ELSEIF (OP.EQ.2) THEN
            IF (.NOT.PSGN(1)) ISI(1)=-ISI(1)
            IF (.NOT.PSGN(2)) ISI(2)=-ISI(2)
            RRI=ISI(1)*ISI(2)
            DONE=.TRUE.
         ELSEIF (OP.EQ.3) THEN
            IF (.NOT.PSGN(1)) ISI(1)=-ISI(1)
            IF (.NOT.PSGN(2)) ISI(2)=-ISI(2)
            RRI=ISI(1)/ISI(2)
            DONE=.TRUE.
         ELSEIF (OP.EQ.4) THEN
            IF (.NOT.PSGN(1)) ISI(1)=-ISI(1)
            IF (.NOT.PSGN(2)) ISI(2)=-ISI(2)
            RRI=ISI(1)+ISI(2)
            DONE=.TRUE.
         ENDIF
         WRITE(STRING3,*)RRI
         PST=(.NOT.(RRI.LT.0))
      ELSEIF ((QREA(1).OR.QINT(1)).AND.
     &        (QREA(2).OR.QINT(2))) THEN
C     CONVERT TO REAL
         IF (QINT(1)) ISR(1)=DFLOAT(ISI(1))
         IF (QINT(2)) ISR(2)=DFLOAT(ISI(2))
         IF (OP.EQ.1) THEN
            IF (.NOT.PSGN(2)) ISR(2)=-ISR(2)
            RRR=ISR(1)**ISR(2)
            IF (.NOT.PSGN(1)) RRR=-RRR
            DONE=.TRUE.
         ELSEIF (OP.EQ.2) THEN
            IF (.NOT.PSGN(1)) ISR(1)=-ISR(1)
            IF (.NOT.PSGN(2)) ISR(2)=-ISR(2)
            RRR=ISR(1)*ISR(2)
            DONE=.TRUE.
         ELSEIF (OP.EQ.3) THEN
            IF (.NOT.PSGN(1)) ISR(1)=-ISR(1)
            IF (.NOT.PSGN(2)) ISR(2)=-ISR(2)
            RRR=ISR(1)/ISR(2)
            DONE=.TRUE.
         ELSEIF (OP.EQ.4) THEN
            IF (.NOT.PSGN(1)) ISR(1)=-ISR(1)
            IF (.NOT.PSGN(2)) ISR(2)=-ISR(2)
            RRR=ISR(1)+ISR(2)
            DONE=.TRUE.
         ENDIF
         WRITE(STRING3,*)RRR
         PST=(.NOT.(RRR.LT.0))
      ENDIF
C
      IF (DONE) THEN
C
         CHANGED=.TRUE.
         CALL CHOP(STRING3,100)
         IF (PST.AND.CAMEWS) THEN
            STRING3='+'//STRING3(1:99)
         ENDIF
C
      ELSE
C
C     ADD PROTECTIVE BRACKETS (OR ELSE '1+(2+3)^b'='6^b'
C
         IF (OP.EQ.1) THEN
            STRING3=STRB1(1:LEN1)//'^'//STRB2(1:LEN2)
         ELSEIF (OP.EQ.2) THEN
            STRING3=STRB1(1:LEN1)//'*'//STRB2(1:LEN2)
         ELSEIF (OP.EQ.3) THEN
            STRING3=STRB1(1:LEN1)//'/'//STRB2(1:LEN2)
         ELSEIF (OP.EQ.4) THEN
            LEN2=LENGTH(STRING2,100,LEN2)
            STRING3=STRB1(1:LEN1)//STRING2(1:LEN2)
         ENDIF
C
C     NO OPERATION WAS PERFORMED
C
         IRC=106
C
         IF (.NOT.CLEAN) THEN
            CALL CHOP(STRING3,100)
            LEN3=LENGTH(STRING3,100,LEN1+LEN2+1)
            STRING3='{'//STRING3(1:LEN3)//'}'
         ENDIF
C
         IF (CAMEWS) THEN
            IF (PSGN(1)) THEN
               STRING3='+'//STRING3(1:99)
            ELSE
               STRING3='-'//STRING3(1:99)
            ENDIF
         ENDIF
      ENDIF
C
      IF (BDEB) THEN
         LEN3=LENGTH(STRING3,100,LEN3)
         WRITE(*,*) MYNAME,'Debug: A1:',
     &     STRING1(1:LEN1),' A2:',STRING2(1:LEN2),
     &     ' A3:',STRING3(1:LEN3),' OP:',OP
      ENDIF
C
      IF (BDEB) WRITE(*,*) MYNAME,'Debug: Routine starts.',IRC
C
      RETURN
      END
#__mcat: substr.F     **DO NOT DELETE
      SUBROUTINE SUBSTR(STRING1,N1,STRING2,N2,POS1,DELL)
C     ***********************************************************************
C     +                                                                     *
C     SUBSTITUTES PART OF STRING1 WITH STRING2                              *
C     +                                                                     *
CIO   STRING1 (C*N1) = STRING WHICH WILL HAVE A SUBSTRING REPLACED          *
CI    N1 (I*4) = LENGTH OF STRING1                                          *
CI    STRING2 (C*N2) = STRING WHICH WILL BE COPIED OVER TO STRING1          *
CI    N2 (I*4) = LENGTH OF STRING2                                          *
CI    POS1 (I*4) = START POSITION IN STRING1                                *
CI    DELL (I*4) = NUMBER OF CHARACTERS TO DELETE IN STRING1                *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N1,N2,POS1,DELL
      CHARACTER*(*) STRING1,STRING2
C
      INTEGER*4 LENS1,LENS2,LENGTH,MAXX,TRG,DELTA,POSS,LL
      EXTERNAL LENGTH
C
C     REMOVE VALUABLE DATA FROM TARGET AREA
C
C     CALL CHOP(STRING1,N1)
      LENS1=LENGTH(STRING1,N1,LENS1)
C
      CALL CHOP(STRING2,N2)
      LENS2=LENGTH(STRING2,N2,LENS2)
C
      IF((POS1+LENS2-1).GT.N1)LENS2=N1+1-POS1
      IF (POS1+DELL-1.GT.LENS1)DELL=LENS1-POS1+1
C
      DELTA=(LENS2-DELL)
C
      MAXX=N1
      MAXX=MIN(MAXX,LENS1+DELTA)
      MAXX=MAXX-DELTA
C
C     MAXX IS LAST DATA (STILL IN ARRAY)
C
      TRG=POS1+DELL
      IF (DELTA.GT.0) THEN
         DO LL=MAXX,TRG,-1
            STRING1(LL+DELTA:LL+DELTA)=STRING1(LL:LL)
         ENDDO
      ELSE
         DO LL=TRG,MAXX
            STRING1(LL+DELTA:LL+DELTA)=STRING1(LL:LL)
         ENDDO
C
C     REMOVE OLD DATA IN EMPTY SLOT (AFTER LAST DATA)
C
         MAXX=MAXX+DELTA+1
         DO LL=MAXX,LENS1
            STRING1(LL:LL)=' '
         ENDDO
      ENDIF
C
      TRG=POS1+LENS2-1
      IF (TRG.GT.N1) TRG=N1
      DO LL=POS1,TRG
         POSS=LL-POS1+1
         STRING1(LL:LL)=STRING2(POSS:POSS)
      ENDDO
C
      RETURN
      END
#__mcat: trunc.F     **DO NOT DELETE
      SUBROUTINE TRUNC(STRING,N)
C     ***********************************************************************
C     +                                                                     *
C     REMOVES TRAILING BLANKS FROM A STRING                                  *
C     +                                                                     *
CIO   STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    N (I*4) = LENGTH OF STRING                                            *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N
      CHARACTER*(*) STRING
      CHARACTER*1 C1
      INTEGER*4 II
      LOGICAL*4 BDONE
C
      LOGICAL*4 FIRST
      DATA FIRST /.TRUE./
C
      IF (FIRST) THEN
         C1=CHAR(0)
         FIRST=.FALSE.
      ENDIF
C
      II=N
      BDONE=(II.LE.0)
      DO WHILE (.NOT. BDONE)
         IF (STRING(II:II).EQ.' ') THEN
            STRING(II:II)=C1
            II=II-1
            BDONE= (II.LE.0)
         ELSE IF (STRING(II:II).EQ.C1) THEN
            II=II-1
         ELSE
            BDONE=.TRUE.
         END IF
      END DO
C
      RETURN
      END
#__mcat: trunc0.F     **DO NOT DELETE
      SUBROUTINE TRUNC0(STRING,N)
C     ***********************************************************************
C     +                                                                     *
C     REMOVES TRAILING 0 FROM EXPRESSION                                    *
C     +                                                                     *
CIO   STRING (C*N) = STRING TO BE EXAMINED                                  *
CI    N (I*4) = LENGTH OF STRING                                            *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N
      CHARACTER*1 STRING(N),BUFF
C
      INTEGER*4 II,LENGTH,LENS,DELL,IIZERO
      LOGICAL*4 DIGIT,ACTIVE
      EXTERNAL LENGTH,DIGIT
C
      LENS=LENGTH(STRING,N,1)
      DELL=1
C
C     REMOVE TRAILING '0'ES
C
      IIZERO=LENS+1
      ACTIVE=.FALSE.
      II=0
      DO WHILE(II.LE.LENS)
         II=II+1
         IF ((II.LE.LENS).AND.
     &        (DIGIT(STRING(II)).OR.
     &        (STRING(II).EQ.'.'))) THEN
            IF (STRING(II).EQ.'0') THEN
               IF (ACTIVE.AND.IIZERO.GT.II) IIZERO=II
            ELSEIF(STRING(II).EQ.'.') THEN
               ACTIVE=.TRUE.
C     WE DO NOT WANT THE PROGRAM TO CONVERT REAL TO INTEGERS, I.E. 11.0 => 11
C     IF (IIZERO.GT.II) IIZERO=II
            ELSE
               IIZERO=LENS+1
            ENDIF
         ELSE
            IF (ACTIVE.AND.IIZERO.LT.II) THEN
C     REMOVE EVERYTHING FROM IIZERO TO II-1
               DELL=II-IIZERO
               CALL SUBSTR(STRING,N,BUFF,0,IIZERO,DELL)
               II=IIZERO+1
               LENS=LENGTH(STRING,N,LENS-DELL)
               IIZERO=LENS+1
            ENDIF
            ACTIVE=.FALSE.
         ENDIF
      ENDDO
C
      LENS=LENGTH(STRING,N,LENS)
      CALL CHOP(STRING,LENS)
C
      RETURN
      END
#__mcat: which.F     **DO NOT DELETE
      SUBROUTINE WHICH(CCHR,CODE)
C     ***********************************************************************
C     +                                                                     *
C     FINDS OUT IF STRING CONTAINS A SPECIAL CHARACTER AT POS               *
C     +                                                                     *
C     CCHR (C*1)                                                            *
CO    CODE (I*4) = OBJECT TYPE IDENTIFIER                                   *
C     +     =0 UNIDENTIFIED                                                 *
C     +     =1 ' '                                                          *
C     +     =2 '^'                                                          *
C     +     =3 '*'                                                          *
C     +     =4 '/'                                                          *
C     +     =5 '+'                                                          *
C     +     =6 '-'                                                          *
C     +     =7 '='                                                          *
C     +     =8 '&'                                                          *
C     +     =9 '|'                                                          *
C     +     =10'>'                                                          *
C     +     =11'<'                                                          *
C     +     =12'!'                                                          *
C     +                                                                     *
C     VERSION                      : 18/07/95                               *
C     +                                                                     *
C     WRITTEN/MODIFIED BY:                                                  *
C     --------------------------------------------------------------------- *
C     |    NAME      |   DATE   |                 REASON                  | *
C     --------------------------------------------------------------------- *
C     | F. TVETER    | 18/07/95 | NEW                                     | *
C     |              |          |                                         | *
C     --------------------------------------------------------------------- *
C     ***********************************************************************
C
C
      IMPLICIT NONE
      SAVE
C
      CHARACTER*1 CCHR,C1
      INTEGER*4 CODE
C
      INTEGER*4 MAXOBJ,II
      PARAMETER (MAXOBJ=13)
      CHARACTER*1 OBJECTS(MAXOBJ)
      LOGICAL*4 FIRST,FOUND
      DATA FIRST/.TRUE./
C
      CHARACTER*8 MYNAME
      DATA MYNAME /'WHICH'/
C
      IF (FIRST) THEN
         C1=CHAR(0)
         OBJECTS(1)=' '
         OBJECTS(2)='^'
         OBJECTS(3)='*'
         OBJECTS(4)='/'
         OBJECTS(5)='+'
         OBJECTS(6)='-'
         OBJECTS(7)='='
         OBJECTS(8)='&'
         OBJECTS(9)='|'
         OBJECTS(10)='>'
         OBJECTS(11)='<'
         OBJECTS(12)='!'
         OBJECTS(13)=C1
         FIRST=.FALSE.
      ENDIF
C
C     SEARCH IN STRING
C
      CODE=0
      II=1
      FOUND=.FALSE.
      DO WHILE (II.LE.MAXOBJ .AND..NOT.FOUND)
         IF (OBJECTS(II).EQ.CCHR) THEN
            IF (.NOT.FOUND) FOUND=.TRUE.
            IF (FOUND) CODE=II
         ELSE
            II=II+1
         ENDIF
      ENDDO
C
      RETURN
      END
#__mcat: wobject.F     **DO NOT DELETE
      SUBROUTINE WOBJECT(STRING,N,START,POS,CODE)
C
C     RETURNS THE 'WHOLE' OBJECT (INCLUDED BRACKETS)
C
      IMPLICIT NONE
      SAVE
C
      INTEGER*4 N
      CHARACTER*1 STRING(N)
      INTEGER*4 START,POS(2),CODE
C
      INTEGER*4 ICODE
      CHARACTER*8 MYNAME
      DATA MYNAME /'OBJECT'/
C
      ICODE=CODE
      CALL OBJECT(STRING,N,START,POS,ICODE)
C
      IF (CODE.EQ.1) THEN
         IF (POS(1).GT.1) THEN
            IF (STRING(POS(1)-1).EQ.'('
     &           .OR.STRING(POS(1)-1).EQ.'[') THEN
               POS(1)=POS(1)-1
               IF (POS(1).GT.1) THEN
                  IF(STRING(POS(1)-1).EQ.'-'
     &                 .OR.STRING(POS(1)-1).EQ.'+') THEN
                     POS(1)=POS(1)-1
                  ENDIF
               ENDIF
            ELSEIF((STRING(POS(1)-1).EQ.'-'
     &              .OR.STRING(POS(1)-1).EQ.'+').AND..NOT.
     &              (STRING(POS(1)).EQ.'-'
     &              .OR.STRING(POS(1)).EQ.'+')) THEN
               POS(1)=POS(1)-1
            ENDIF
         ENDIF
         POS(2)=START
      ELSEIF (CODE.EQ.-1) THEN
         POS(1)=START
         IF (POS(2).LT.N) THEN
            IF (STRING(POS(2)+1).EQ.')'
     &           .OR.STRING(POS(2)+1).EQ.']') POS(2)=POS(2)+1
         ENDIF
      ENDIF
C
      CODE=ICODE
C
      RETURN
      END
