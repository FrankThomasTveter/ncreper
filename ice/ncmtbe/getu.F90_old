real function getu(aa,bb,cc,dd,val,bok,irc)
  ! solves: val = aa + bb*u  + cc*uu**2 + dd*uu**3
  implicit none
  real aa,bb,cc,dd,val
  logical :: bok
  integer :: irc
  !
  INTEGER INFORM, ITER, N,NBND, &
       &     NCLIN,NCNLN,LIWORK,LWORK,NROWA, &
       &     NROWJ,NROWR,MAXBND 
  DOUBLE PRECISION   OBJF
  PARAMETER (&
       &     N = 1,&
       &     NCLIN  =  0,&
       &     NCNLN  =  0,&
       &     NROWA  =  NCLIN, &
       &     NROWJ  =  1, &
       &     NROWR =   N,&
       &     LIWORK =  3*n+NCLIN+2*NCNLN,&
       &     LWORK  =  2*N*N + N*NCLIN + 2*N*NCNLN + 20*N + 11*NCLIN + 21*NCNLN,&
       &     MAXBND =  N + NROWA + NROWJ)
  INTEGER            ISTATE(MAXBND)
  INTEGER            IWORK(LIWORK)
  DOUBLE PRECISION   A(NROWA,N)
  DOUBLE PRECISION   BL(MAXBND) 
  DOUBLE PRECISION   BU(MAXBND)
  DOUBLE PRECISION   C(NROWJ) 
  DOUBLE PRECISION   CJAC(NROWJ,N) 
  DOUBLE PRECISION   CLAMDA(MAXBND)
  DOUBLE PRECISION   OBJGRD(N) 
  DOUBLE PRECISION   R(NROWR,N) 
  DOUBLE PRECISION   X(N)
  DOUBLE PRECISION   WORK(LWORK)
  !
  INTEGER II,JJ,XPOS
  !
  CHARACTER*16 MYNAME
  DATA MYNAME /'GETABC'/
  !
  !     MINIMISE
  !
  CALL NPOPTN( 'NOLIST')
  CALL NPOPTN( 'Major print level              0')
  CALL NPOPTN( 'Minor print level              0')
  !CALL NPOPTN( '   Derivative level               0')
  !CALL NPOPTN( '   Step Level                   1.0')
  !CALL NPOPTN( '   Verify                       Yes')
  ! CALL NPOPTN( '   Optimal Tolerance      0.0000001')
  ! CALL NPOPTN( '   Warm Start')
  ! CALL NPOPTN( '   Cold Start')
  ! CALL NPOPTN( '   Major iteration limit        100')
  !
  NBND   = N + NCLIN + NCNLN
  !
  BL(1)=-1.0D2
  BU(1)=1.0D2
  X(1)=0.0D0
  !
  CALL IFU(aa,bb,cc,dd,val)
  CALL NPSOL ( N, NCLIN, NCNLN, NROWA, NROWJ, NROWR,&
       &           A, BL, BU,&
       &           CFU, OFU,&
       &           INFORM, ITER, ISTATE,&
       &           C, CJAC, CLAMDA, OBJF, OBJGRD, R, X,&
       &           IWORK, LIWORK, WORK, LWORK )
  ! inform 1: no further improvement possible
  ! inform 2: no feasible point within linear constraints
  ! inform 3: no feasible point within non-linear constraints
  ! inform 4: reached iteration limit (Major iteration limit)
  ! inform 6: too small tolerance?
  ! inform 7: incorrect derivatives
  ! inform 9: invalid input parameter
  ! overflow: increase "Linear Feasibility Tolerance" or "Nonlinear Feasibility Tolerance"
  IF (INFORM .GT. 1) THEN ! ignore iteration limit errors  
     if (inform.ne.4.and.inform.ne.6) then
        IRC=INFORM
        WRITE(*,*) MYNAME,'Error return from NPSOL.',IRC, x
        CALL NPOPTN( '   Major print level             10')
        CALL NPOPTN( '   Minor print level              5')
        CALL NPOPTN( '   Verify                       Yes')
        !
        X(1)=0.0D0
        !
        write(*,*) ' aa=',aa
        write(*,*) ' bb=',bb
        write(*,*) ' cc=',cc
        write(*,*) ' dd=',dd
        write(*,*) ' val=',val
        CALL NPSOL ( N, NCLIN, NCNLN, NROWA, NROWJ, NROWR,&
             &           A, BL, BU,&
             &           CFU, OFU,&
             &           INFORM, ITER, ISTATE,&
             &           C, CJAC, CLAMDA, OBJF, OBJGRD, R, X,&
             &           IWORK, LIWORK, WORK, LWORK )
        WRITE(*,*) MYNAME,'Second return from NPSOL.',inform
        getu=x(1)
     else
        getu=x(1)
     end if
     bok=.false.
  else
     !write(*,*)myname,'Found:',x(1),val,&
     !& aa+bb*x(1)+cc*x(1)**2+dd*x(1)**3
     getu=x(1)
     !     
     bok=.true.
  END IF
  RETURN
contains
  !
  ! initialise common blocks
  subroutine IFU(ia,ib,ic,id,ival)
    implicit none
    real ia,ib,ic,id,ival
    real aa,bb,cc,dd,val
    common /cmb_u /aa,bb,cc,dd,val
    ! initialise common blocks
    aa=ia
    bb=ib
    cc=ic
    dd=id
    val=ival
    return
  end subroutine IFU
  !
  SUBROUTINE OFU( MODE,N,X,OBJF,OBJGRD,NSTATE )
    !***************************************************************
    !***************************************************************
    !**   This routine was generated by the                         **
    !**   Tangent linear and Adjoint Model Compiler,  TAMC 5.3.0    **
    !***************************************************************
    !***************************************************************
    !==============================================
    !     all entries are defined explicitly
    !==============================================
    implicit none
    save
    !
    integer mode
    integer n
    double precision x(n)
    double precision objf
    double precision objgrd(n)
    integer nstate
    integer irc
    character*16 myname
    data myname /'OBJFN'/
    real aa,bb,cc,dd,val
    common /cmb_u /aa,bb,cc,dd,val
    real :: ss1,ss2,ss3,ss4,dx,dxda,dxdb,dxdc,dxdd,ddx
    !write(*,*)'FNCU Entering.',s(1),kk
    ss1=x(1)
    ss2=ss1*ss1
    ss3=ss1*ss2
    dx=aa + ss1*bb + ss2*cc + ss3*dd - val
    dxda=1.0D0
    dxdb=ss1
    dxdc=ss2
    dxdd=ss3
    OBJF= dx*dx
    ddx=2.0D0*dx
    OBJGRD(1)=ddx*dxda
    OBJGRD(2)=ddx*dxdb
    OBJGRD(3)=ddx*dxdc
    OBJGRD(4)=ddx*dxdd
    !write(*,*)'OFU:',x(1),objf
    return
  end subroutine OFU
  !
  SUBROUTINE CFU(MODE, NCNLN, N, NROWJ,&
       &     NEEDC, X, C, CJAC, NSTATE )
    !     DUMMY ROUTINE
    SAVE
    integer :: mode, ncnln, n, nrowj,NEEDC(*)
    DOUBLE PRECISION   X(N), C(*), CJAC(NROWJ,*)
    integer nstate
    CHARACTER*16 MYNAME
    DATA MYNAME /'CONFN'/
    WRITE(*,*) MYNAME,'This routine should never be called.'
    !
    RETURN
  END SUBROUTINE CFU
  !
end function getu
